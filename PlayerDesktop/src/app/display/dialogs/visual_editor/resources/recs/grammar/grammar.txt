//------------------------------------------------------------------------------
// game

<game>     ::= (game <string>) |
               (game <string> <players> [<mode>] <equipment> <rules.rules>) |
               <match>

//------------------------------------------------------------------------------
// game.players

<players>  ::= (players <int>) | (players {<players.player>})
<players.player> ::= (player <directionFacing>)

//------------------------------------------------------------------------------
// game.equipment.other

<dominoes> ::= (dominoes [upTo:<int>])
<hints>    ::= (hints [<string>] {<equipment.hint>} [<siteType>])
<map>      ::= (map [<string>] {<int>} {<int>}) | (map [<string>] {<math.pair>})
<regions>  ::= (regions [<string>] [<roleType>] ({<int>} | <sites> | {<sites>} |
               <regionTypeStatic> | {<regionTypeStatic>}) [<string>])

//------------------------------------------------------------------------------
// game.equipment.container.board

<container.board.board> ::= (board <graph> [<board.track> |
               {<board.track>}] [<equipment.values> |
               {<equipment.values>}] [use:<siteType>] [largeStack:<boolean>]) |
               <boardless> | <mancalaBoard> | <surakartaBoard>
<board.track> ::= (track <string> ({<int>} | <string> |
               {<equipment.trackStep>}) [loop:<boolean>] [<int> |
               <roleType>] [directed:<boolean>])
<boardless> ::= (boardless <tilingBoardlessType> [<dim>] [largeStack:<boolean>])

//------------------------------------------------------------------------------
// game.equipment.container.board.custom

<mancalaBoard> ::= (mancalaBoard <int> <int> [store:<storeType>] [numStores:<int>] [largeStack:<boolean>] [<board.track>
               | {<board.track>}])
<surakartaBoard> ::= (surakartaBoard <graph> [loops:<int>] [from:<int>] [largeStack:<boolean>])

//------------------------------------------------------------------------------
// game.rules.play.moves.nonDecision.effect

<effect>   ::= <effect.add> | <addScore> | <attract> | <avoidStoredState> |
               <bet> | <claim> | <custodial> | <effect.deal> | <directional> |
               <do> | <enclose> | <firstMoveOnTrack> | <flip> |
               <operators.foreach.forEach> | <forget> | <fromTo> | <hop> |
               <intervene> | <leap> | <max.max> | <moveAgain> | <note> |
               <pass> | <playCard> | <priority> | <promote> | <propose> |
               <push> | <remember> | <effect.remove> | <roll> | <satisfy> |
               <select> | <effect.set.set> | <shoot> | <slide> | <sow> |
               <effect.step> | <surround> | <swap.swap> | <take> | <trigger> |
               <vote> | <while>
<apply>    ::= (apply if:<boolean>) | (apply <nonDecision>) |
               (apply if:<boolean> <nonDecision>)
<attract>  ::= (attract [<moves.from>] [<absoluteDirection>] [<then>])
<bet>      ::= (bet (<moves.player> | <roleType>) <range> [<then>])
<claim>    ::= (claim [<moves.piece>] <moves.to> [<then>])
<custodial> ::= (custodial [<moves.from>] [<absoluteDirection>] [<moves.between>] [<moves.to>] [<then>])
<directional> ::= (directional [<moves.from>] [<direction>] [<moves.to>] [<then>])
<effect.add> ::= (add [<moves.piece>] <moves.to> [count:<int>] [stack:<boolean>] [<then>])
<effect.deal> ::= (deal <dealableType> [<int>] [beginWith:<int>] [<then>])
<effect.remove> ::= (remove [<siteType>] (<int> |
               <sites>) [level:<int>] [at:<whenType>] [count:<int>] [<then>])
<effect.step> ::= (step [<moves.from>] [<direction>] <moves.to> [stack:<boolean>] [<then>])
<enclose>  ::= (enclose [<siteType>] [<moves.from>] [<direction>] [<moves.between>] [numException:<int>] [<then>])
<flip>     ::= (flip [<siteType>] [<int>] [<then>])
<fromTo>   ::= (fromTo <moves.from> <moves.to> [count:<int>] [copy:<boolean>] [stack:<boolean>] [<roleType>] [<then>])
<hop>      ::= (hop [<moves.from>] [<direction>] [<moves.between>] <moves.to> [stack:<boolean>] [<then>])
<intervene> ::= (intervene [<moves.from>] [<absoluteDirection>] [<moves.between>] [<moves.to>] [<then>])
<leap>     ::= (leap [<moves.from>] {{<stepType>}} [forward:<boolean>] [rotations:<boolean>] <moves.to> [<then>])
<note>     ::= (note [player:<int> | player:<roleType>] (<string> | <int> |
               <ints> | <float> | <boolean> | <sites> | <range> | <direction> |
               <graph>) [to:<moves.player> | to:<roleType>])
<pass>     ::= (pass [<then>])
<playCard> ::= (playCard [<then>])
<promote>  ::= (promote [<siteType>] [<int>] <moves.piece> [<moves.player> |
               <roleType>] [<then>])
<propose>  ::= (propose (<string> | {<string>}) [<then>])
<push>     ::= (push [<moves.from>] <direction> [<then>])
<random>   ::= (random <moves> num:<int>) | (random {<float>} {<moves>})
<roll>     ::= (roll [<then>])
<satisfy>  ::= (satisfy (<boolean> | {<boolean>}))
<select>   ::= (select <moves.from> [<moves.to>] [<roleType>] [<then>])
<shoot>    ::= (shoot <moves.piece> [<moves.from>] [<absoluteDirection>] [<moves.between>] [<moves.to>] [<then>])
<slide>    ::= (slide [<moves.from>] [<string>] [<direction>] [<moves.between>] [<moves.to>] [stack:<boolean>] [<then>])
<sow>      ::= (sow [<siteType>] [<int>] [count:<int>] [numPerHole:<int>] [<string>] [owner:<int>] [if:<boolean>] [sowEffect:<moves>] [apply:<nonDecision>] [includeSelf:<boolean>] [origin:<boolean>] [skipIf:<boolean>] [backtracking:<boolean>
               | forward:<boolean>] [<then>])
<surround> ::= (surround [<moves.from>] [<relationType>] [<moves.between>] [<moves.to>] [except:<int>] [with:<moves.piece>] [<then>])
<then>     ::= (then <nonDecision> [applyAfterAllMoves:<boolean>])
<trigger>  ::= (trigger <string> (<int> | <roleType>) [<then>])
<vote>     ::= (vote (<string> | {<string>}) [<then>])

//------------------------------------------------------------------------------
// game.rules.play.moves

<moves>    ::= <effect.add> | <addScore> | <allCombinations> | <logical.and> |
               <append> | <apply> | <attract> | <avoidStoredState> | <bet> |
               <claim> | <custodial> | <effect.deal> | <decision> |
               <directional> | <do> | <effect> | <enclose> |
               <firstMoveOnTrack> | <flip> | <operators.foreach.forEach> |
               <forget> | <fromTo> | <hop> | <logical.if> | <intervene> |
               <leap> | <max.max> | <move> | <moveAgain> | <nonDecision> |
               <note> | <operator> | <logical.or> | <pass> | <playCard> |
               <priority> | <promote> | <propose> | <push> | <random> |
               <remember> | <effect.remove> | <roll> | <satisfy> | <select> |
               <effect.set.set> | <shoot> | <slide> | <sow> | <effect.step> |
               <surround> | <swap.swap> | <take> | <trigger> | <vote> | <while>

//------------------------------------------------------------------------------
// game.rules.play.moves.decision

<decision> ::= <move>
<move>     ::= (move Set Rotation [<moves.to>] [{<int>} |
               <int>] [previous:<boolean>] [next:<boolean>] [<then>]) |
               (move Step [<moves.from>] [<direction>] <moves.to> [stack:<boolean>] [<then>])
               |
               (move Slide [<moves.from>] [<string>] [<direction>] [<moves.between>] [<moves.to>] [stack:<boolean>] [<then>])
               |
               (move Shoot <moves.piece> [<moves.from>] [<absoluteDirection>] [<moves.between>] [<moves.to>] [<then>])
               |
               (move Select <moves.from> [<moves.to>] [<roleType>] [<then>]) |
               (move Swap Players (<int> <roleType>) (<int> <roleType>) [<then>])
               | (move Swap Pieces [<int>] [<int>] [<then>]) |
               (move Remove [<siteType>] (<int> |
               <sites>) [level:<int>] [at:<whenType>] [count:<int>] [<then>]) |
               (move Set TrumpSuit (<int> |
               <intArray.math.difference>) [<then>]) |
               (move Set NextPlayer (<moves.player> | <ints>) [<then>]) |
               (move Hop [<moves.from>] [<direction>] [<moves.between>] <moves.to> [stack:<boolean>] [<then>])
               |
               (move <moves.from> <moves.to> [count:<int>] [copy:<boolean>] [stack:<boolean>] [<roleType>] [<then>])
               | (move Bet (<moves.player> | <roleType>) <range> [<then>]) |
               (move <moveSiteType> [<moves.piece>] <moves.to> [count:<int>] [stack:<boolean>] [<then>])
               | (move <moveMessageType> (<string> | {<string>}) [<then>]) |
               (move Promote [<siteType>] [<int>] <moves.piece> [<moves.player>
               | <roleType>] [<then>]) |
               (move Leap [<moves.from>] {{<stepType>}} [forward:<boolean>] [rotations:<boolean>] <moves.to> [<then>])
               | (move <moveSimpleType> [<then>])
<moveMessageType> ::= Propose | Vote
<moveSimpleType> ::= Pass | PlayCard
<moveSiteType> ::= Add | Claim

//------------------------------------------------------------------------------
// game.rules.play.moves.nonDecision

<nonDecision> ::= <effect> | <operator>

//------------------------------------------------------------------------------
// game.rules.play.moves.nonDecision.effect.requirement

<avoidStoredState> ::= (avoidStoredState <moves> [<then>])
<do>       ::= (do <moves> [next:<moves>] [ifAfterwards:<boolean>] [<then>])
<firstMoveOnTrack> ::= (firstMoveOnTrack [<string>] [<roleType>] <moves> [<then>])
<priority> ::= (priority <moves> <moves> [<then>]) |
               (priority {<moves>} [<then>])
<while>    ::= (while <boolean> <moves> [<then>])

//------------------------------------------------------------------------------
// game.rules.play.moves.nonDecision.effect.requirement.max

<max.max>  ::= (max Distance [<string>] [<roleType>] <moves> [<then>]) |
               (max <maxMovesType> [withValue:<boolean>] <moves> [<then>])
<maxMovesType> ::= Captures | Moves

//------------------------------------------------------------------------------
// game.rules.play.moves.nonDecision.effect.set

<effect.set.set> ::= (set NextPlayer (<moves.player> | <ints>) [<then>]) |
               (set Rotation [<moves.to>] [{<int>} |
               <int>] [previous:<boolean>] [next:<boolean>] [<then>]) |
               (set <setPlayerType> (<moves.player> |
               <roleType>) <int> [<then>]) | (set TrumpSuit (<int> |
               <intArray.math.difference>) [<then>]) |
               (set Hidden [<hiddenData> |
               {<hiddenData>}] [<siteType>] (at:<int> |
               <sites>) [level:<int>] [<boolean>] (to:<moves.player> |
               to:<roleType>) [<then>]) |
               (set Team <int> {<roleType>} [<then>]) |
               (set <setSiteType> [<siteType>] at:<int> [level:<int>] <int> [<then>])
               | (set <setValueType> [<int>] [<then>]) | (set Pending [<int> |
               <sites>] [<then>]) | (set Var [<string>] [<int>] [<then>])
<setPlayerType> ::= Score | Value
<setSiteType> ::= Count | State | Value
<setValueType> ::= Counter | Pot

//------------------------------------------------------------------------------
// game.rules.play.moves.nonDecision.effect.state

<addScore> ::= (addScore ({<int>} | {<roleType>}) {<int>} [<then>]) |
               (addScore (<moves.player> | <roleType>) <int> [<then>])
<moveAgain> ::= (moveAgain [<then>])

//------------------------------------------------------------------------------
// game.rules.play.moves.nonDecision.effect.state.forget

<forget>   ::= (forget Value [<string>] <int> [<then>]) |
               (forget Value [<string>] All [<then>])

//------------------------------------------------------------------------------
// game.rules.play.moves.nonDecision.effect.state.remember

<remember> ::= (remember State [<then>]) |
               (remember Value [<string>] <int> [unique:<boolean>] [<then>])

//------------------------------------------------------------------------------
// game.rules.play.moves.nonDecision.effect.state.swap

<swap.swap> ::= (swap Players (<int> | <roleType>) (<int> |
               <roleType>) [<then>]) | (swap Pieces [<int> <int>] [<then>])

//------------------------------------------------------------------------------
// game.rules.play.moves.nonDecision.effect.take

<take>     ::= (take Control (of:<roleType> | of:<int>) (by:<roleType> |
               by:<int>) [at:<int> | to:<sites>] [<siteType>] [<then>]) |
               (take Domino [<then>])

//------------------------------------------------------------------------------
// game.rules.play.moves.nonDecision.operators.foreach

<operators.foreach.forEach> ::= (forEach Die [<int>] [combined:<boolean>] [replayDouble:<boolean>] [if:<boolean>] <moves> [<then>])
               |
               (forEach Direction [<moves.from>] [<direction>] [<moves.between>] (<moves.to>
               | <moves>) [<then>]) |
               (forEach Site <sites> <moves> [noMoveYet:<moves>] [<then>]) |
               (forEach Group [<siteType>] [<direction>] [if:<boolean>] <moves> [<then>])
               | (forEach Team <moves> [<then>]) |
               (forEach Level [<siteType>] <int> [<stackDirection>] <moves> [<then>])
               | (forEach <ints> <moves> [<then>]) |
               (forEach Player <moves> [<then>]) |
               (forEach Value <ints> <moves> [<then>]) |
               (forEach Piece [on:<siteType>] [<string> |
               {<string>}] [container:<int> |
               <string>] [<moves>] [<moves.player> |
               <roleType>] [top:<boolean>] [<then>]) |
               (forEach Value min:<int> max:<int> <moves> [<then>])

//------------------------------------------------------------------------------
// game.rules.play.moves.nonDecision.operator

<operator> ::= <allCombinations> | <logical.and> | <append> | <logical.if> |
               <logical.or>

//------------------------------------------------------------------------------
// game.rules.play.moves.nonDecision.operators.logical

<allCombinations> ::= (allCombinations <moves> <moves> [<then>])
<append>   ::= (append <nonDecision> [<then>])
<logical.and> ::= (and {<moves>} [<then>]) | (and <moves> <moves> [<then>])
<logical.if> ::= (if <boolean> <moves> [<moves>] [<then>])
<logical.or> ::= (or {<moves>} [<then>]) | (or <moves> <moves> [<then>])

//------------------------------------------------------------------------------
// game.rules.phase

<phase.phase> ::= (phase <string> [<roleType>] [<mode>] <play> [<end>] [<nextPhase>
               | {<nextPhase>}])
<nextPhase> ::= (nextPhase [<roleType> | <moves.player>] [<boolean>] [<string>])

//------------------------------------------------------------------------------
// game.mode

<mode>     ::= (mode <modeType>)

//------------------------------------------------------------------------------
// game.equipment

<equipment> ::= (equipment {<item>})
<item>     ::= <component> | <container> | <dominoes> | <hints> | <map> |
               <regions>

//------------------------------------------------------------------------------
// game.equipment.component

<component> ::= (component <string> <roleType> {{<stepType>}} <directionFacing> <moves> <int> <int> <int>)
               | <component.card> | <die> | <domino> | <component.piece> |
               <tile>
<component.card> ::= (card <string> <roleType> <cardType> rank:<int> value:<int> trumpRank:<int> trumpValue:<int> suit:<int> [<moves>] [maxState:<int>] [maxCount:<int>] [maxValue:<int>])
<component.piece> ::= (piece <string> [<roleType>] [<directionFacing>] [<flips>] [<moves>] [maxState:<int>] [maxCount:<int>] [maxValue:<int>])
<die>      ::= (die <string> <roleType> numFaces:<int> [<directionFacing>] [<moves>])

//------------------------------------------------------------------------------
// game.equipment.component.tile

<tile>     ::= (tile <string> [<roleType>] [{<stepType>} |
               {{<stepType>}}] [numSides:<int>] [slots:{<int>} |
               slotsPerSide:<int>] [{<path>}] [<flips>] [<moves>] [maxState:<int>] [maxCount:<int>] [maxValue:<int>])
<domino>   ::= (domino <string> <roleType> value:<int> value2:<int> [<moves>])
<path>     ::= (path from:<int> [slotsFrom:<int>] to:<int> [slotsTo:<int>] colour:<int>)

//------------------------------------------------------------------------------
// game.equipment.container

<container> ::= <container.board.board> | <deck> | <dice> | <other.hand>

//------------------------------------------------------------------------------
// game.equipment.container.other

<deck>     ::= (deck [<roleType>] [cardsBySuit:<int>] [suits:<int>] [{<equipment.card>}])
<dice>     ::= (dice [d:<int>] [faces:{<int>} | facesByDie:{{<int>}} |
               from:<int>] [<roleType>] num:<int> [biased:{<int>}])
<other.hand> ::= (hand <roleType> [size:<int>])

//------------------------------------------------------------------------------
// game.rules

<rules.rules> ::= (rules [<meta>] [<start>] [<play>] phases:{<phase.phase>} [<end>])
               | (rules [<meta>] [<start>] <play> <end>)

//------------------------------------------------------------------------------
// game.rules.meta

<meta>     ::= (meta ({<metaRule>} | <metaRule>))
<automove> ::= (automove)
<gravity>  ::= (gravity [PyramidalDrop])
<meta.swap> ::= (swap)
<metaRule> ::= <automove> | <gravity> | <meta.no.no> | <passEnd> | <pin> |
               <meta.swap>
<passEnd>  ::= (passEnd <passEndType>)
<pin>      ::= (pin SupportMultiple)

//------------------------------------------------------------------------------
// game.rules.meta.no

<meta.no.no> ::= (no Suicide) | (no Repeat [<repetitionType>])

//------------------------------------------------------------------------------
// game.rules.start

<start>    ::= (start ({<startRule>} | <startRule>))
<start.deal> ::= (deal <dealableType> [<int>])
<startRule> ::= <start.deal> | <forEach.forEach> | <place> |
               <deductionPuzzle.set> | <start.set.set> | <split>

//------------------------------------------------------------------------------
// game.rules.start.deductionPuzzle

<deductionPuzzle.set> ::= (set [<siteType>] {{<int>}})

//------------------------------------------------------------------------------
// game.rules.start.forEach

<forEach.forEach> ::= (forEach Player <startRule>) |
               (forEach Value min:<int> max:<int> <startRule>) |
               (forEach Site <sites> [if:<boolean>] <startRule>) |
               (forEach Team <startRule>) | (forEach <ints> <startRule>)

//------------------------------------------------------------------------------
// game.rules.start.place

<place>    ::= (place Random [<sites>] {<string>} [count:<int>] [state:<int>] [value:<int>] [<siteType>])
               | (place Stack (<string> |
               items:{<string>}) [<string>] [<siteType>] [<int> | {<int>} |
               <sites> | coord:<string> | {<string>}] [count:<int> |
               counts:{<int>}] [state:<int>] [rotation:<int>] [value:<int>]) |
               (place <string> [<siteType>] [{<int>}] [<sites>] [{<string>}] [counts:{<int>}] [state:<int>] [rotation:<int>] [value:<int>])
               |
               (place <string> [<string>] [<siteType>] [<int>] [coord:<string>] [count:<int>] [state:<int>] [rotation:<int>] [value:<int>])
               | (place Random {<math.count>} <int> [<siteType>]) |
               (place Random {<string>} [count:{<int>}] [state:<int>] [value:<int>] <int> [<siteType>])

//------------------------------------------------------------------------------
// game.rules.start.set

<start.set.set> ::= (set <roleType> [<siteType>] [{<int>}] [<sites>] [{<string>}])
               | (set <roleType> [<siteType>] [<int>] [coord:<string>]) |
               (set Hidden [<hiddenData> |
               {<hiddenData>}] [<siteType>] (at:<int> |
               <sites>) [level:<int>] [<boolean>] to:<roleType>) |
               (set RememberValue [<string>] (<int> |
               <sites>) [unique:<boolean>]) | (set Team <int> {<roleType>}) |
               (set <setStartSitesType> <int> [<siteType>] (at:<int> |
               to:<sites>)) | (set <setStartPlayerType> [<roleType>] <int>)
<setStartPlayerType> ::= Amount | Score
<setStartSitesType> ::= Cost | Count | Phase

//------------------------------------------------------------------------------
// game.rules.start.split

<split>    ::= (split Deck)

//------------------------------------------------------------------------------
// game.rules.play

<play>     ::= (play <moves>)

//------------------------------------------------------------------------------
// game.rules.end

<end>      ::= (end (<endRule> | {<endRule>}))
<byScore>  ::= (byScore [{<end.score>}])
<end.forEach> ::= (forEach [<roleType> | Track] if:<boolean> <result>)
<end.if>   ::= (if <boolean> [<end.if> | {<end.if>}] [<result>])
<endRule>  ::= <end.forEach> | <end.if>
<payoffs>  ::= (payoffs {<payoff>})
<result>   ::= (result <roleType> <resultType>) | <byScore> | <payoffs>

//------------------------------------------------------------------------------
// game.match

<match>    ::= (match <string>) | (match <string> [<players>] <games> <end>)
<games>    ::= (games (<subgame> | {<subgame>}))
<subgame>  ::= (subgame <string> [<string>] [next:<int>] [result:<int>])

//------------------------------------------------------------------------------
// game.functions.booleans.was

<was>      ::= (was Pass)

//------------------------------------------------------------------------------
// game.functions.booleans.no

<booleans.no.no> ::= (no Moves <roleType>) |
               (no Pieces [<siteType>] [<roleType> |
               of:<int>] [<string>] [in:<sites>])

//------------------------------------------------------------------------------
// game.functions.booleans.math

<!=>       ::= (!= <sites> <sites>) | (!= <int> (<int> | <roleType>))
<<>        ::= (< <int> <int>)
<<=>       ::= (<= <int> <int>)
<=>        ::= (= <sites> <sites>) | (= <int> (<int> | <roleType>))
<>>        ::= (> <int> <int>)
<>=>       ::= (>= <int> <int>)
<booleans.math.if> ::= (if <boolean> <boolean> [<boolean>])
<math.and> ::= (and {<boolean>}) | (and <boolean> <boolean>)
<math.or>  ::= (or {<boolean>}) | (or <boolean> <boolean>)
<not>      ::= (not <boolean>)
<xor>      ::= (xor <boolean> <boolean>)

//------------------------------------------------------------------------------
// game.functions.booleans.is

<booleans.is.is> ::= (is Triggered <string> (<int> | <roleType>)) |
               (is <isSimpleType>) | (is Crossing <int> <int>) |
               (is <isStringType> <string>) | (is <isGraphType> <siteType>) |
               (is Hidden [<hiddenData>] [<siteType>] at:<int> [level:<int>] (to:<moves.player>
               | to:<roleType>)) | (is Repeat [<repetitionType>]) |
               (is Pattern {<stepType>} [<siteType>] [from:<int>] [what:<int> |
               whats:{<int>}]) | (is <isTreeType> (<moves.player> |
               <roleType>)) | (is RegularGraph (<moves.player> |
               <roleType>) [k:<int> | odd:<boolean> | even:<boolean>]) |
               (is <isPlayerType> (<int> | <roleType>)) |
               (is Line [<siteType>] <int> [<absoluteDirection>] [through:<int>
               | throughAny:<sites>] [<roleType> | what:<int> |
               whats:{<int>}] [exact:<boolean>] [contiguous:<boolean>] [if:<boolean>] [byLevel:<boolean>])
               | (is Loop [<siteType>] [surround:<roleType> |
               {<roleType>}] [<direction>] [<int>] [<int> |
               <sites>] [path:<boolean>]) |
               (is Path <siteType> [from:<int>] (<moves.player> |
               <roleType>) length:<range> [closed:<boolean>]) |
               (is <isSiteType> [<siteType>] <int>) | (is In [<int> |
               {<int>}] (<sites> | <ints>)) | (is <isIntegerType> [<int>]) |
               (is <isComponentType> [<int>] [<siteType>] [at:<int> |
               in:<sites>] [<moves>]) |
               (is <isConnectType> [<int>] [<siteType>] [at:<int>] [<direction>] ({<sites>}
               | <roleType> | <regionTypeStatic>)) |
               (is Related <relationType> [<siteType>] <int> (<int> |
               <sites>)) | (is Target [<int> | <string>] {<int>} [<int> |
               {<int>}])
<isComponentType> ::= Threatened | Within
<isConnectType> ::= Blocked | Connected
<isGraphType> ::= LastFrom | LastTo
<isIntegerType> ::= AnyDie | Even | Flat | Odd | PipsMatch | SidesMatch | Visited
<isPlayerType> ::= Active | Enemy | Friend | Mover | Next | Prev
<isSimpleType> ::= Cycle | Full | Pending
<isSiteType> ::= Empty | Occupied
<isStringType> ::= Decided | Proposed
<isTreeType> ::= CaterpillarTree | SpanningTree | Tree | TreeCentre

//------------------------------------------------------------------------------
// game.functions.booleans.deductionPuzzle.is

<deductionPuzzle.is.is> ::= (is Unique [<siteType>]) |
               (is <isPuzzleRegionResultType> [<siteType>] [<sites>] [of:<int>] [<string>] <int>)
               | (is Solved)
<isPuzzleRegionResultType> ::= Count | Sum

//------------------------------------------------------------------------------
// game.functions.booleans.deductionPuzzle.all

<deductionPuzzle.all.all> ::= (all Different [<siteType>] [<sites>] [except:<int>
               | excepts:{<int>}])

//------------------------------------------------------------------------------
// game.functions.booleans.deductionPuzzle

<forAll>   ::= (forAll <puzzleElementType> <boolean>)

//------------------------------------------------------------------------------
// game.functions.booleans.can

<can>      ::= (can Move <moves>)

//------------------------------------------------------------------------------
// game.functions.booleans.all

<booleans.all.all> ::= (all Values <ints> if:<boolean>) |
               (all <allSitesType> <sites> if:<boolean>) |
               (all <allSimpleType>) |
               (all Groups [<siteType>] [<direction>] [of:<boolean>] if:<boolean>)
<allSimpleType> ::= DiceEqual | DiceUsed | Passed
<allSitesType> ::= Different | Sites

//------------------------------------------------------------------------------
// game.functions.ints.value

<value>    ::= (value Piece [<siteType>] at:<int> [level:<int>]) |
               (value Player (<int> | <roleType>)) |
               (value <valueSimpleType>) | (value Random <range>) | (value)
<valueSimpleType> ::= MoveLimit | Pending | TurnLimit

//------------------------------------------------------------------------------
// game.functions.ints.trackSite

<trackSite> ::= (trackSite Move [from:<int>] [<roleType> | <moves.player> |
               <string>] steps:<int>) | (trackSite EndSite [<moves.player> |
               <roleType>] [<string>]) | (trackSite FirstSite [<moves.player> |
               <roleType>] [<string>] [from:<int>] [if:<boolean>])

//------------------------------------------------------------------------------
// game.functions.ints.tile

<pathExtent> ::= (pathExtent [<int>] [<int> | <sites>])

//------------------------------------------------------------------------------
// game.functions.ints.state

<state>    ::= (state [<siteType>] at:<int> [level:<int>])
<amount>   ::= (amount (<roleType> | <moves.player>))
<counter>  ::= (counter)
<mover>    ::= (mover)
<next>     ::= (next)
<pot>      ::= (pot)
<prev>     ::= (prev [<prevType>])
<rotation> ::= (rotation [<siteType>] at:<int> [level:<int>])
<state.score> ::= (score (<moves.player> | <roleType>))
<var>      ::= (var [<string>])
<what>     ::= (what [<siteType>] at:<int> [level:<int>])
<who>      ::= (who [<siteType>] at:<int> [level:<int>])

//------------------------------------------------------------------------------
// game.functions.ints.stacking

<topLevel> ::= (topLevel [<siteType>] at:<int>)

//------------------------------------------------------------------------------
// game.functions.ints.size

<size>     ::= (size Group [<siteType>] at:<int> [<direction>] [if:<boolean>]) |
               (size LargePiece [<siteType>] (in:<sites> | at:<int>)) |
               (size Stack [<siteType>] [in:<sites> | at:<int>]) |
               (size Array <ints>) | (size Territory [<siteType>] (<roleType> |
               <moves.player>) [<absoluteDirection>])

//------------------------------------------------------------------------------
// game.functions.ints.math

<%>        ::= (% <int> <int>)
<ints.math.*> ::= (* ({<int>} | <ints>)) | (* <int> <int>)
<ints.math.+> ::= (+ ({<int>} | <ints>)) | (+ <int> <int>)
<ints.math.-> ::= (- [<int>] <int>)
<ints.math./> ::= (/ <int> <int>)
<ints.math.^> ::= (^ <int> <int>)
<ints.math.abs> ::= (abs <int>)
<ints.math.if> ::= (if <boolean> <int> <int>)
<ints.math.max> ::= (max <ints>) | (max <int> <int>)
<ints.math.min> ::= (min <ints>) | (min <int> <int>)

//------------------------------------------------------------------------------
// game.functions.ints.match

<matchScore> ::= (matchScore <roleType>)

//------------------------------------------------------------------------------
// game.functions.ints.last

<ints.last.last> ::= (last <lastType> [afterConsequence:<boolean>])
<lastType> ::= From | LevelFrom | LevelTo | To

//------------------------------------------------------------------------------
// game.functions.ints.iterator

<iterator.between> ::= (between)
<iterator.edge> ::= (edge) | (edge <int> <int>)
<iterator.from> ::= (from [at:<whenType>])
<iterator.hint> ::= (hint [<siteType>] [at:<int>])
<iterator.player> ::= (player)
<iterator.to> ::= (to)
<iterator.track> ::= (track)
<level>    ::= (level)
<pips>     ::= (pips)
<site>     ::= (site)

//------------------------------------------------------------------------------
// game.functions.ints.dice

<dice.face> ::= (face <int>)

//------------------------------------------------------------------------------
// game.functions.ints.count

<count.count> ::= (count <countComponentType> [<siteType>] [<roleType> |
               of:<int>] [<string>] [in:<sites>] [if:<boolean>]) |
               (count [<countSiteType>] [<siteType>] [in:<sites> | at:<int> |
               <string>]) | (count <countSimpleType> [<siteType>]) |
               (count Stack [<stackDirection>] [<siteType>] (at:<int> |
               to:<sites>) [if:<boolean>] [stop:<boolean>]) |
               (count Value <int> in:<ints>) |
               (count StepsOnTrack [<roleType> | <moves.player> |
               <string>] [<int>] [<int>]) |
               (count Steps [<siteType>] [<relationType>] [<effect.step>] [newRotation:<int>] <int> (<int>
               | <sites>)) |
               (count Groups [<siteType>] [<direction>] [if:<boolean>] [min:<int>])
               |
               (count Liberties [<siteType>] [at:<int>] [<direction>] [if:<boolean>])
<countComponentType> ::= Pieces | Pips
<countSimpleType> ::= Active | Cells | Columns | Edges | LegalMoves | Moves |
               MovesThisTurn | Phases | Players | Rows | Trials | Turns |
               Vertices
<countSiteType> ::= Adjacent | Diagonal | Neighbours | Off | Orthogonal | Sites

//------------------------------------------------------------------------------
// game.functions.ints.card

<card.card> ::= (card <cardSiteType> at:<int> [level:<int>]) | (card TrumpSuit)
<cardSiteType> ::= Rank | Suit | TrumpRank | TrumpValue

//------------------------------------------------------------------------------
// game.functions.ints.board.where

<where>    ::= (where Level <string> (<int> |
               <roleType>) [state:<int>] [<siteType>] at:<int> [fromTop:<boolean>])
               | (where <int> [<siteType>]) | (where <string> (<int> |
               <roleType>) [state:<int>] [<siteType>]) |
               (where Level <int> [<siteType>] at:<int> [fromTop:<boolean>])

//------------------------------------------------------------------------------
// game.functions.region.sites

<sites>    ::= (sites <sitesEdgeType>) | (sites Group [<siteType>] (at:<int> |
               from:<sites>) [<direction>] [if:<boolean>]) |
               (sites Crossing at:<int> [<moves.player> | <roleType>]) |
               (sites ({<int>} | <ints>)) | (sites <sitesMoveType> <moves>) |
               (sites [<siteType>] {<string>}) |
               (sites <sitesSimpleType> [<siteType>]) | (sites) |
               (sites Loop [inside:<boolean>] [<siteType>] [surround:<roleType>
               | {<roleType>}] [<direction>] [<int>] [<int> | <sites>]) |
               (sites Pattern {<stepType>} [<siteType>] [from:<int>] [what:<int>
               | whats:{<int>}]) | (sites Random [<sites>] [num:<int>]) |
               (sites LargePiece [<siteType>] at:<int>) |
               (sites Between [<direction>] [<siteType>] from:<int> [fromIncluded:<boolean>] to:<int> [toIncluded:<boolean>] [cond:<boolean>])
               | (sites Hidden [<hiddenData>] [<siteType>] (to:<moves.player> |
               to:<roleType>)) | (sites Start <moves.piece>) |
               (sites Occupied (by:<moves.player> |
               by:<roleType>) [container:<int> |
               container:<string>] [component:<int> | component:<string> |
               components:{<string>}] [top:<boolean>] [on:<siteType>]) |
               (sites Incident <siteType> of:<siteType> at:<int> [owner:<moves.player>
               | <roleType>]) | (sites Around [<siteType>] (<int> |
               <sites>) [<regionTypeDynamic>] [distance:<int>] [<absoluteDirection>] [if:<boolean>] [includeSelf:<boolean>])
               | (sites Direction (from:<int> |
               from:<sites>) [<direction>] [included:<boolean>] [stop:<boolean>] [stopIncluded:<boolean>] [distance:<int>] [<siteType>])
               |
               (sites LineOfSight [<lineOfSightType>] [<siteType>] [at:<int>] [<direction>])
               |
               (sites [<siteType>] [<int>] {{<stepType>}} [rotations:<boolean>])
               | (sites <sitesIndexType> [<siteType>] [<int>]) |
               (sites Side [<siteType>] [<moves.player> | <roleType> |
               <compassDirection>]) |
               (sites <sitesPlayerType> [<siteType>] [<moves.player> |
               <roleType>] [<nonDecision>] [<string>]) |
               (sites Track [<moves.player> |
               <roleType>] [<string>] [from:<int>] [to:<int>]) |
               (sites Distance [<siteType>] [<relationType>] [<effect.step>] [newRotation:<int>] from:<int> <range>)
               | (sites [<moves.player> |
               <roleType>] [<siteType>] [<string>]) |
               (region <equipment.region>) | (region) | (region int) |
               (region <string> <container.board.board> {<string>}) |
               (region) | (region) | (region {int}) | (region) |
               <region.math.difference> | <expand> | <region.foreach.forEach> |
               <region.math.if> | <region.math.intersection> |
               <region.last.last> | <region.math.union>
<lineOfSightType> ::= Empty | Farthest | Piece
<sitesEdgeType> ::= Angled | Axial | Horizontal | Slash | Slosh | Vertical
<sitesIndexType> ::= Cell | Column | Edge | Empty | Layer | Phase | Row | State
<sitesMoveType> ::= Between | From | To
<sitesPlayerType> ::= Hand | Winning
<sitesSimpleType> ::= Board | Bottom | Centre | ConcaveCorners | ConvexCorners |
               Corners | Hint | Inner | LastFrom | LastTo | Left | LineOfPlay |
               Major | Minor | Outer | Pending | Perimeter | Playable | Right |
               ToClear | Top

//------------------------------------------------------------------------------
// game.functions.region.math

<expand>   ::= (expand [<int> | <string>] (<sites> |
               origin:<int>) [steps:<int>] [<absoluteDirection>] [<siteType>])
<region.math.difference> ::= (difference <sites> (<sites> | <int>))
<region.math.if> ::= (if <boolean> <sites> [<sites>])
<region.math.intersection> ::= (intersection {<sites>}) |
               (intersection <sites> <sites>)
<region.math.union> ::= (union {<sites>}) | (union <sites> <sites>)

//------------------------------------------------------------------------------
// game.functions.region.last

<region.last.last> ::= (last Between)

//------------------------------------------------------------------------------
// game.functions.region.foreach

<region.foreach.forEach> ::= (forEach of:<sites> <sites>) |
               (forEach <sites> if:<boolean>) | (forEach Team <sites>) |
               (forEach Level [<siteType>] at:<int> [<stackDirection>] [if:<boolean>] [startAt:<int>])
               | (forEach <ints> <sites>)

//------------------------------------------------------------------------------
// game.functions.range.math

<exact>    ::= (exact <int>)
<range.math.max> ::= (max <int>)
<range.math.min> ::= (min <int>)

//------------------------------------------------------------------------------
// game.functions.range

<range>    ::= (range <int> [<int>]) | <exact> | <range.math.max> |
               <range.math.min>

//------------------------------------------------------------------------------
// game.functions.graph.operators

<clip>     ::= (clip <graph> <poly>)
<complete> ::= (complete <graph> [eachCell:<boolean>])
<dual>     ::= (dual <graph>)
<hole>     ::= (hole <graph> <poly>)
<intersect> ::= (intersect {<graph>}) | (intersect <graph> <graph>)
<keep>     ::= (keep <graph> <poly>)
<layers>   ::= (layers <dim> <graph>)
<makeFaces> ::= (makeFaces <graph>)
<merge>    ::= (merge {<graph>} [connect:<boolean>]) |
               (merge <graph> <graph> [connect:<boolean>])
<operators.add> ::= (add [<graph>] [vertices:{{<float>}}] [edges:{{{<float>}}} |
               edges:{{<dim>}}] [edgesCurved:{{{<float>}}}] [cells:{{{<float>}}}
               | cells:{{<dim>}}] [connect:<boolean>])
<operators.remove> ::= (remove <graph> <poly> [trimEdges:<boolean>]) |
               (remove <graph> [cells:{{{<float>}}} |
               cells:{<dim>}] [edges:{{{<float>}}} |
               edges:{{<dim>}}] [vertices:{{<float>}} |
               vertices:{<dim>}] [trimEdges:<boolean>])
<operators.union> ::= (union {<graph>} [connect:<boolean>]) |
               (union <graph> <graph> [connect:<boolean>])
<recoordinate> ::= (recoordinate [<siteType>] [<siteType>] [<siteType>] <graph>)
<renumber> ::= (renumber [<siteType>] [<siteType>] [<siteType>] <graph>)
<rotate>   ::= (rotate <float> <graph>)
<scale>    ::= (scale <float> [<float>] [<float>] <graph>)
<shift>    ::= (shift <float> <float> [<float>] <graph>)
<skew>     ::= (skew <float> <graph>)
<splitCrossings> ::= (splitCrossings <graph>)
<subdivide> ::= (subdivide <graph> [min:<dim>])
<trim>     ::= (trim <graph>)

//------------------------------------------------------------------------------
// game.functions.graph.generators.shape.concentric

<concentric> ::= (concentric (<concentricShapeType> | sides:<dim> |
               {<dim>}) [rings:<dim>] [steps:<dim>] [midpoints:<boolean>] [joinMidpoints:<boolean>] [joinCorners:<boolean>] [stagger:<boolean>])
<concentricShapeType> ::= Hexagon | Square | Target | Triangle

//------------------------------------------------------------------------------
// game.functions.graph.generators.shape

<rectangle> ::= (rectangle <dim> [<dim>] [diagonals:<diagonalsType>])
<regular>  ::= (regular <basisType> <shapeType> <dim> [<dim>]) |
               (regular [Star] <dim>)
<repeat>   ::= (repeat <dim> <dim> step:{{<float>}} (<poly> | {<poly>}))
<spiral>   ::= (spiral turns:<dim> sites:<dim> [clockwise:<boolean>])
<wedge>    ::= (wedge <dim> [<dim>])

//------------------------------------------------------------------------------
// game.functions.graph.generators.basis.tri

<tri>      ::= (tri (<poly> | {<dim>})) | (tri [<triShapeType>] <dim> [<dim>])
<triShapeType> ::= Diamond | Hexagon | Limping | NoShape | Prism | Rectangle |
               Square | Star | Triangle

//------------------------------------------------------------------------------
// game.functions.graph.generators.basis.tiling

<tiling>   ::= (tiling <tilingType> <dim> [<dim>]) |
               (tiling <tilingType> (<poly> | {<dim>}))
<tilingType> ::= T31212 | T333333_33434 | T33336 | T33344 | T33434 | T3464 |
               T3636 | T4612 | T488

//------------------------------------------------------------------------------
// game.functions.graph.generators.basis.square

<square>   ::= (square (<poly> | {<dim>}) [diagonals:<diagonalsType>]) |
               (square [<squareShapeType>] <dim> [diagonals:<diagonalsType> |
               pyramidal:<boolean>])
<diagonalsType> ::= Alternating | Concentric | Implied | Radiating | Solid
<squareShapeType> ::= Diamond | Limping | NoShape | Rectangle | Square

//------------------------------------------------------------------------------
// game.functions.graph.generators.basis.quadhex

<quadhex>  ::= (quadhex <dim> [thirds:<boolean>])

//------------------------------------------------------------------------------
// game.functions.graph.generators.basis.hex

<hex>      ::= (hex (<poly> | {<dim>})) | (hex [<hexShapeType>] <dim> [<dim>])
<hexShapeType> ::= Diamond | Hexagon | Limping | NoShape | Prism | Rectangle |
               Square | Star | Triangle

//------------------------------------------------------------------------------
// game.functions.graph.generators.basis.celtic

<celtic>   ::= (celtic (<poly> | {<dim>})) | (celtic <dim> [<dim>])

//------------------------------------------------------------------------------
// game.functions.graph.generators.basis.brick

<brick>    ::= (brick [<brickShapeType>] <dim> [<dim>] [trim:<boolean>])
<brickShapeType> ::= Diamond | Limping | Prism | Rectangle | Spiral | Square

//------------------------------------------------------------------------------
// game.functions.graph.generators.basis

<basis>    ::= <brick> | <celtic> | <concentric> | <hex> | <quadhex> |
               <rectangle> | <spiral> | <square> | <tiling> | <tri> | <wedge>

//------------------------------------------------------------------------------
// game.functions.intArray.values

<values.values> ::= (values Remembered [<string>])

//------------------------------------------------------------------------------
// game.functions.intArray.state

<rotations> ::= (rotations (<absoluteDirection> | {<absoluteDirection>}))

//------------------------------------------------------------------------------
// game.functions.intArray.sizes

<sizes>    ::= (sizes Group [<siteType>] [<direction>] [<roleType> | of:<int> |
               if:<boolean>] [min:<int>])

//------------------------------------------------------------------------------
// game.functions.intArray.players

<intArray.players.players> ::= (players <playersTeamType> [if:<boolean>]) |
               (players <playersManyType> [of:<int>] [if:<boolean>])
<playersManyType> ::= All | Ally | Enemy | Friend | NonMover
<playersTeamType> ::= Team1 | Team10 | Team11 | Team12 | Team13 | Team14 |
               Team15 | Team16 | Team2 | Team3 | Team4 | Team5 | Team6 |
               Team7 | Team8 | Team9

//------------------------------------------------------------------------------
// game.functions.intArray.math

<intArray.math.difference> ::= (difference <ints> (<ints> | <int>))
<intArray.math.if> ::= (if <boolean> <ints> [<ints>])
<intArray.math.intersection> ::= (intersection {<ints>}) |
               (intersection <ints> <ints>)
<intArray.math.union> ::= (union {<ints>}) | (union <ints> <ints>)
<results>  ::= (results (from:<int> | from:<sites>) (to:<int> |
               to:<sites>) <int>)

//------------------------------------------------------------------------------
// game.functions.intArray.iteraror

<team>     ::= (team)

//------------------------------------------------------------------------------
// game.functions.intArray.array

<array>    ::= (array {<int>}) | (array <sites>)

//------------------------------------------------------------------------------
// game.functions.ints.board

<ahead>    ::= (ahead [<siteType>] <int> [steps:<int>] [<direction>])
<arrayValue> ::= (arrayValue <ints> index:<int>)
<board.id> ::= (id <string>) | (id [<string>] <roleType>)
<board.phase> ::= (phase [<siteType>] of:<int>)
<centrePoint> ::= (centrePoint [<siteType>])
<column>   ::= (column [<siteType>] of:<int>)
<coord>    ::= (coord [<siteType>] row:<int> column:<int>) |
               (coord [<siteType>] <string>)
<cost>     ::= (cost [<siteType>] (at:<int> | in:<sites>))
<handSite> ::= (handSite (<int> | <roleType>) [<int>])
<layer>    ::= (layer of:<int> [<siteType>])
<mapEntry> ::= (mapEntry [<string>] (<int> | <roleType>))
<regionSite> ::= (regionSite <sites> index:<int>)
<row>      ::= (row [<siteType>] of:<int>)

//------------------------------------------------------------------------------
// game.functions.floats.math

<cos>      ::= (cos <float>)
<exp>      ::= (exp <float>)
<floats.math.*> ::= (* {<float>}) | (* <float> <float>)
<floats.math.+> ::= (+ {<float>}) | (+ <float> <float>)
<floats.math.-> ::= (- <float> <float>)
<floats.math./> ::= (/ <float> <float>)
<floats.math.^> ::= (^ <float> <float>)
<floats.math.abs> ::= (abs <float>)
<floats.math.max> ::= (max {<float>}) | (max <float> <float>)
<floats.math.min> ::= (min {<float>}) | (min <float> <float>)
<log>      ::= (log <float>)
<log10>    ::= (log10 <float>)
<sin>      ::= (sin <float>)
<sqrt>     ::= (sqrt <float>)
<tan>      ::= (tan <float>)

//------------------------------------------------------------------------------
// game.functions.floats

<float>    ::= <floats.math.*> | <floats.math.+> | <floats.math.-> |
               <floats.math./> | <floats.math.^> | <floats.math.abs> | <cos> |
               <exp> | float | <log> | <log10> | <floats.math.max> |
               <floats.math.min> | <sin> | <sqrt> | <tan> | <toFloat>
<toFloat>  ::= (toFloat (<boolean> | <int>))

//------------------------------------------------------------------------------
// game.functions.dim.math

<dim.math.*> ::= (* {<dim>}) | (* <dim> <dim>)
<dim.math.+> ::= (+ {<dim>}) | (+ <dim> <dim>)
<dim.math.-> ::= (- <dim> <dim>)
<dim.math./> ::= (/ <dim> <dim>)
<dim.math.^> ::= (^ <dim> <dim>)
<dim.math.abs> ::= (abs <dim>)
<dim.math.max> ::= (max <dim> <dim>)
<dim.math.min> ::= (min <dim> <dim>)

//------------------------------------------------------------------------------
// game.functions.dim

<dim>      ::= <dim.math.*> | <dim.math.+> | <dim.math.-> | <dim.math./> |
               <dim.math.^> | <dim.math.abs> | int | <dim.math.max> |
               <dim.math.min>

//------------------------------------------------------------------------------
// game.functions.ints

<ints>     ::= {<int>} | <array> | <intArray.math.difference> |
               <intArray.math.if> | <intArray.math.intersection> |
               <intArray.players.players> | <regions> | <results> |
               <rotations> | <sizes> | <team> | <intArray.math.union> |
               <values.values>
<int>      ::= <%> | <dim.math.*> | <ints.math.*> | <dim.math.+> |
               <ints.math.+> | <dim.math.-> | <ints.math.-> | <dim.math./> |
               <ints.math./> | End | Infinity | Off | Undefined |
               <dim.math.^> | <ints.math.^> | <dim.math.abs> |
               <ints.math.abs> | <ahead> | <amount> | <arrayValue> |
               <iterator.between> | <card.card> | <centrePoint> | <column> |
               <coord> | <cost> | <count.count> | <counter> | <iterator.edge> |
               <dice.face> | <iterator.from> | <handSite> | <iterator.hint> |
               <board.id> | <ints.math.if> | int | <ints.last.last> | <layer> |
               <level> | <mapEntry> | <matchScore> | <dim.math.max> |
               <ints.math.max> | <dim.math.min> | <ints.math.min> | <mover> |
               <next> | <nextPhase> | <pathExtent> | <board.phase> | <pips> |
               <iterator.player> | <pot> | <prev> | <regionSite> | <rotation> |
               <row> | <state.score> | <site> | <size> | <state> |
               <iterator.to> | <toInt> | <topLevel> | <iterator.track> |
               <trackSite> | <value> | <var> | <what> | <where> | <who>
<toInt>    ::= (toInt (<boolean> | <float>))

//------------------------------------------------------------------------------
// game.functions.booleans

<boolean>  ::= <!=> | <<> | <<=> | <=> | <>> | <>=> | <booleans.all.all> |
               <deductionPuzzle.all.all> | <math.and> | boolean | <can> |
               <forAll> | <booleans.math.if> | <deductionPuzzle.is.is> |
               <booleans.is.is> | <booleans.no.no> | <not> | <math.or> |
               <toBool> | <was> | <xor>
<toBool>   ::= (toBool (<int> | <float>))

//------------------------------------------------------------------------------
// game.functions.directions

<directions> ::= (directions (<absoluteDirection> | {<absoluteDirection>})) |
               (directions [<relativeDirection> |
               {<relativeDirection>}] [of:<relationType>] [bySite:<boolean>]) |
               (directions <siteType> from:<int> to:<int>) |
               (directions Random <direction> num:<int>)
<directions.difference> ::= (difference <direction> <direction>)
<directions.if> ::= (if <boolean> <direction> <direction>)
<directions.union> ::= (union <direction> <direction>)

//------------------------------------------------------------------------------
// game.util.end

<end.score> ::= (score <roleType> <int>)
<payoff>   ::= (payoff <roleType> <float>)

//------------------------------------------------------------------------------
// game.util.math

<math.count> ::= (count <string> <int>)
<math.pair> ::= (pair <string> <string>) | (pair <roleType> <roleType>) |
               (pair <roleType> <int>) | (pair <int> <int>) |
               (pair <string> <roleType>) | (pair <roleType> <landmarkType>) |
               (pair <roleType> <string>) | (pair <int> <string>)

//------------------------------------------------------------------------------
// game.util.moves

<flips>    ::= (flips <int> <int>)
<moves.between> ::= (between [before:<int>] [<range>] [after:<int>] [if:<boolean>] [trail:<int>] [<apply>])
<moves.from> ::= (from [<siteType>] [<sites> |
               <int>] [level:<int>] [if:<boolean>])
<moves.piece> ::= (piece (<string> | <int> | {<string>} | {<int>}) [state:<int>])
<moves.player> ::= (player <int>)
<moves.to> ::= (to [<siteType>] [<sites> |
               <int>] [level:<int>] [<rotations>] [if:<boolean>] [<apply>])

//------------------------------------------------------------------------------
// game.util.graph

<graph>    ::= (graph vertices:{{<float>}} [edges:{{<int>}}]) | (graph) |
               (graph <graph>) | (graph) | <operators.add> | <basis> |
               <brick> | <celtic> | <clip> | <complete> | <concentric> |
               <dual> | <hex> | <hole> | <intersect> | <keep> | <layers> |
               <makeFaces> | <merge> | <quadhex> | <recoordinate> | <regular> |
               <operators.remove> | <renumber> | <repeat> | <rotate> |
               <scale> | <shift> | <skew> | <spiral> | <splitCrossings> |
               <square> | <subdivide> | <tiling> | <tri> | <trim> |
               <operators.union> | <wedge>
<poly>     ::= (poly {{<dim>}}) | (poly {{<float>}})

//------------------------------------------------------------------------------
// game.util.equipment

<equipment.card> ::= (card <cardType> rank:<int> value:<int> [trumpRank:<int>] [trumpValue:<int>] [biased:<int>])
<equipment.hint> ::= (hint <int> [<int>]) | (hint {<int>} [<int>])
<equipment.values> ::= (values <siteType> <range>)

//------------------------------------------------------------------------------
// game.util.directions

<direction> ::= <absoluteDirection> | <directions.difference> | <directions> |
               <directions.if> | <relativeDirection> | <directions.union>
<absoluteDirection> ::= Adjacent | All | Angled | Axial | Base | CCW | CW | D |
               DE | DN | DNE | DNW | DS | DSE | DSW | DW | Diagonal |
               Downward | E | ENE | ESE | In | N | NE | NNE | NNW | NW |
               OffDiagonal | Orthogonal | Out | Rotational | S | SE | SSE |
               SSW | SW | SameLayer | Support | U | UE | UN | UNE | UNW | US |
               USE | USW | UW | Upward | W | WNW | WSW
<compassDirection> ::= E | ENE | ESE | N | NE | NNE | NNW | NW | S | SE | SSE |
               SSW | SW | W | WNW | WSW
<directionFacing> ::= <absoluteDirection> | <directions> | <directions.if> |
               <relativeDirection>
<relativeDirection> ::= BL | BLL | BLLL | BR | BRR | BRRR | Backward |
               Backwards | FL | FLL | FLLL | FR | FRR | FRRR | Forward |
               Forwards | Leftward | Leftwards | OppositeDirection |
               Rightward | Rightwards | SameDirection
<stackDirection> ::= FromBottom | FromTop

//------------------------------------------------------------------------------
// game.types.component

<cardType> ::= Ace | Eight | Five | Four | Jack | Joker | King | Nine | Queen |
               Seven | Six | Ten | Three | Two
<dealableType> ::= Cards | Dominoes
<suitType> ::= Clubs | Diamonds | Hearts | Spades

//------------------------------------------------------------------------------
// game.types.play

<modeType> ::= Alternating | Simulation | Simultaneous
<passEndType> ::= Draw | NoEnd
<prevType> ::= Mover | MoverLastTurn
<repetitionType> ::= Positional | PositionalInTurn | Situational |
               SituationalInTurn
<resultType> ::= Abandon | Crash | Draw | Loss | Tie | Win
<roleType> ::= All | Ally | Each | Enemy | Friend | Mover | Neutral | Next |
               NonMover | P1 | P10 | P11 | P12 | P13 | P14 | P15 | P16 | P2 |
               P3 | P4 | P5 | P6 | P7 | P8 | P9 | Player | Prev | Shared |
               Team1 | Team10 | Team11 | Team12 | Team13 | Team14 | Team15 |
               Team16 | Team2 | Team3 | Team4 | Team5 | Team6 | Team7 | Team8 |
               Team9 | TeamMover
<whenType> ::= EndOfTurn | StartOfTurn

//------------------------------------------------------------------------------
// game.types.board

<basisType> ::= Brick | Celtic | Circle | Concentric | Dual | Hexagonal |
               HexagonalPyramidal | Mesh | Morris | NoBasis | QuadHex |
               Spiral | Square | SquarePyramidal | T31212 | T333333_33434 |
               T33336 | T33344 | T33434 | T3464 | T3636 | T4612 | T488 |
               Triangular
<hiddenData> ::= Count | Rotation | State | Value | What | Who
<landmarkType> ::= BottomSite | CentreSite | FirstSite | LastSite | LeftSite |
               RightSite | Topsite
<puzzleElementType> ::= Cell | Edge | Hint | Vertex
<regionTypeDynamic> ::= Empty | Enemy | NotEmpty | NotEnemy | NotOwn | Own
<regionTypeStatic> ::= AllDirections | AllSites | Columns | Corners |
               Diagonals | HintRegions | Layers | Regions | Rows | Sides |
               SidesNoCorners | SubGrids | Touching | Vertices
<relationType> ::= Adjacent | All | Diagonal | OffDiagonal | Orthogonal
<shapeType> ::= Circle | Cross | Custom | Diamond | Hexagon | Limping |
               NoShape | Polygon | Prism | Quadrilateral | Rectangle |
               Regular | Rhombus | Spiral | Square | Star | Triangle | Wedge |
               Wheel
<siteType> ::= Cell | Edge | Vertex
<stepType> ::= F | L | R
<storeType> ::= Inner | None | Outer
<tilingBoardlessType> ::= Hexagonal | Square | Triangular

//------------------------------------------------------------------------------
// game.types

<string>   ::= string

