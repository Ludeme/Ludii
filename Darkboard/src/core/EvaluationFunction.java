/*
 * Created on 2-mar-06
 *
 */
package core;

import java.util.Vector;

import core.algorithm.EvaluationTableAlgorithm;
import core.algorithm.SelectionAlgorithm;

/**
 * @author Nikola Novarlic
 *
 * Defines an evaluation function, and the requirements
 * for it to be used.
 */
public class EvaluationFunction {
	
	/**
	 * This Vector hosts the components that calculate the eval function.
	 * They are computed and summed in the specified order. Components should be
	 * added in the constructor.
	 */
	Vector componentVector = new Vector();
	SelectionAlgorithm algorithm = new EvaluationTableAlgorithm();
	
	/**
	 * Static data used to share stuff across all components to avoid repeating the same calculations.
	 */
	public static int index; //square index of the destination of a move
	public static int opponentTotalAge; //total of age values on chessboard
	public static core.ExtendedEvaluationTree currentNode; //current game tree node, for attaching test info
	
	/**
	 * Takes the incoming metaposition and umpire messages, deciding whether it can
	 * evaluate them. We maintain a Vector of evaluation functions; the first function to
	 * return true is the one actually used.
	 * @param root
	 * @param capx
	 * @param capy
	 * @param check1
	 * @param check2
	 * @param tries
	 * @return
	 */
	public boolean canHandleSituation(core.Metaposition root,
									  int capx, int capy, int check1, int check2, int tries)
	{
		return true;
	}
	
	public String getName() { return "Generic Evaluation Function"; }
	
	public SelectionAlgorithm getSelectionAlgorithm()
	{
		return algorithm;
	}
	
	public int getComponentNumber()
	{
		return componentVector.size();
	}
	
	public core.EvaluationFunctionComponent getComponent(int k)
	{
		if (k<0 || k>=getComponentNumber())
		{
			System.out.println("Exceeded component number: "+k);
			return null;
		}
		return (core.EvaluationFunctionComponent)componentVector.get(k);
	}
	
	public void addComponent(core.EvaluationFunctionComponent efc)
	{
		componentVector.add(efc);
	}
	
	/**
	 * Evaluates a move between two metapositions, by calling every component in turn.
	 */
	public float evaluate(core.Metaposition start, core.Metaposition dest, Move m, Vector history)
	{
		float result = 0.0f;
		float subresult;
		
		//In case we try to evaluate the same node more than once...
		if (currentNode!=null && currentNode.componentNumber()>0) currentNode = null;
		
		boolean extended = currentNode!=null;
		int number = getComponentNumber();
		
		float value=0.0f;
		int index = (m!=null? m.toX*8 + m.toY : -1);
		
		opponentTotalAge = 0;
		start.owner.globals.materialDelta = start.owner.globals.totalMaterial - dest.piecesLeft - dest.pawnsLeft;
		start.owner.globals.materialRatio = 1.0f * start.owner.globals.totalMaterial / (dest.piecesLeft + dest.pawnsLeft);
		dest.calculateFriendlyMaterial();
		dest.computeKingLocation();
	
		dest.computeProtectionMatrix(true);
		
		for (int k=0; k<8; k++) start.owner.globals.pawnSquaresInFiles[k] = 0;
		for (int k=0; k<8; k++)
		{
			for (int j=0; j<8; j++)
			{
				if (dest.canContainEnemyPawn(k,j))
				{
					start.owner.globals.pawnSquaresInFiles[k]++;
				}
			}
			//if (pawnSquaresInFiles[k]==0) result += 1.0f;
		}
		
		/*Evaluate each component in turn.*/
		for (int k=0; k<number; k++)
		{
			core.EvaluationFunctionComponent efc = getComponent(k);
			subresult = efc.evaluate(start,dest,m,history);
			result += subresult;
			
			if (extended)
			{
				//we are using the extended tree, meaning that the component may
				//attach custom information. If it does not, however, we go with
				//a default behavior and attach the subresult as a Float.
				if (!efc.generatesCustomReport())
					currentNode.addInformation(new Float(subresult));
					
			}
		}
		
		return result;
	}
	
	/**
	 * An 'automatic' move is generated by a different algorithm and never
	 * even enters the minimax. This is interrogated before the minimax is
	 * launched, and immediately chosen if not null.
	 * @param in
	 * @return
	 */
	public Move getAutomaticMove(core.Metaposition in)
	{
		return null;
	}
	
	/**
	 * Defines how chessboards are to be generated. Generic assumptions can be made for
	 * general-purpose functions, whereas endgame-specific functions can provide more detail.
	 * @param source
	 * @param m
	 * @return
	 */
	public core.Metaposition generateMostLikelyEvolution(core.Metaposition source, Move m)
	{
		core.Metaposition s;
		boolean pawnTry = (m.piece==Chessboard.PAWN && m.fromX!=m.toX);
		
		//we are pessimistic about captures, except for pawn tries and power moves
		boolean pMove = (source.getAge()==0 && source.isPowerMove(m));
		int captureType = (!pawnTry && source.mayBeEmpty(m.toX,m.toY) && !pMove? Chessboard.NO_CAPTURE :
			source.canContainEnemyPawn(m.toX,m.toY)? Chessboard.CAPTURE_PAWN : Chessboard.CAPTURE_PIECE);
		
		if (captureType != Chessboard.NO_CAPTURE) m.capture = true; //will be used by eval function
		
		int opponentTries = 0;
		if (m.toX>0 && m.toY!=source.getLastRank() && m.toY!=source.getSecondLastRank()
			&& source.canContainEnemyPawn(m.toX-1,m.toY+(source.isWhite()?1:-1))) opponentTries++;
		if (m.toX<7 && m.toY!=source.getLastRank() && m.toY!=source.getSecondLastRank()
			&& source.canContainEnemyPawn(m.toX+1,m.toY+(source.isWhite()?1:-1))) opponentTries++;
		
		s = core.Metaposition.evolveAfterMove(source,m,captureType,m.toX,m.toY,Chessboard.NO_CHECK,Chessboard.NO_CHECK,
			opponentTries);
		
		return s;
	}
	
	/**
	 * If the evaluation function returns a lower value than this, the node will not be further expanded.
	 * @return
	 */
	public float getMinValueForExpansion() { return -150.0f; }
	
	/**
	 * If the evaluation function returns a higher value than this, the node will not be further expanded.
	 * @return
	 */
	public float getMaxValueForExpansion() { return 400.0f; }
	
	/**
	 * Whether loop detection should be used. Generally avoided in endgame-oriented functions.
	 * @return
	 */
	public boolean useLoopDetector() { return false; }
	
	/**
	 * Whether killer heuristics should be used. Again, an exhaustive approach is often better in the endgame.
	 * @return
	 */
	public boolean useKillerPruning() { return true; }
	
	/**
	 * Alpha is the main exploration parameter, the value of a node is
	 * computed as its static value multiplied by alpha plus the value
	 * of its best child multiplied by (1-alpha). It serves as a measure
	 * of how much risk this evaluation function can take, and does not
	 * need be constant. High values are conservative, low values take risks.
	 * @param m
	 * @return
	 */
	public float getExplorationAlpha(core.Metaposition m)
	{
		return 0.9f;
	}

	/**
	 * Multiplies the number of positions to be searched by this number.
	 * Useful for load balancing, time control, and so on.
	 * @param m
	 * @return
	 */
	public float getNodeMultFactor(core.Metaposition m)
	{
		return 1.0f;
	}
	
	/**
	 * Returns an algorithm-based move...
	 * @param m
	 * @return
	 */
	public Move getAlgorithmicMove(core.Metaposition m)
	{
		return null;
	}
	
	public void algorithmicMoveAccepted(core.Metaposition m, Move move, core.Metaposition m2)
	{
		
	}
	
	public void algorithmicMoveRejected(core.Metaposition m, Move move, core.Metaposition m2)
	{
		
	}
}
