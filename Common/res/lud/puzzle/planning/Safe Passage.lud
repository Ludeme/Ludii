(define "NextCanNotMove"
    (not (can Move (do (forEach Piece Next) ifAfterwards:(not ("IsInCheck" "King" Next)))))
)

//**** Defines used to model the castling Moves. ****
(define "KingInTheInitialPlace"
    (= (what at:(mapEntry "King" (mover))) (id "King" Mover))
)

(define "HasNeverMoved"
    (= (state at:(mapEntry #1 (mover))) 1) 
)

(define "PieceHasMoved"
    (set State at:(last To) 0) 
)

(define "RememberPieceHasMoved"
    (then 
        (if 
            (= (state at:(last To)) 1) 
            "PieceHasMoved"
        ) 
    ) 
)

(define "KingNotCheckedAndToEmpty"
    (and 
        (is Empty (to)) 
        (not ("IsInCheck" "King" Mover at:(to)))
    ) 
)

(define "DoCastle"
    (move
        Slide 
        (from (mapEntry #1 (mover))) 
        #2 
        (between 
            (exact #3) 
            if:#4
        ) 
        #5
    )
)

(define "SmallCastling"
    ("DoCastle" "King" E 2 "KingNotCheckedAndToEmpty" (then (and ("PieceHasMoved") ("DoCastle" "RookRight" W 2 True))))
)

(define "BigCastling"
    ("DoCastle" "King" W 2 "KingNotCheckedAndToEmpty" (then (and ("PieceHasMoved") ("DoCastle" "RookLeft" E 3 True))))
)

(define "Castling"
    (if (and {
            "KingInTheInitialPlace" 
            ("HasNeverMoved" "King")
            (not ("IsInCheck" "King" Mover)) 
        })
        (or
            (if (and 
                    ("HasNeverMoved" "RookLeft")
                    (can Move ("DoCastle" "RookLeft" E 3 (is Empty (to))))
                )
                "BigCastling"
            )
            (if (and 
                    ("HasNeverMoved" "RookRight")
                    (can Move ("DoCastle" "RookRight" W 2 (is Empty (to))))
                )
                "SmallCastling"
            )
        )
    )		
)

//**** Defines used to model the extra Pawn moves. ****
(define "SetEnPassantLocation"
    (then 
        (set Pending (ahead (last To) Backward))
    )
)

(define "InLocationEnPassant"
    (and 
        (is Pending) 
        (= (to) (value Pending)) 
    )
)

(define "EnPassant"
    (move
        Step 
        (directions {FR FL}) 
        (to if:"InLocationEnPassant") 
        (then 
            (remove 
                (ahead (last To) Backward)
            )
        )
    )
)

(define "InitialPawnMove"
    (if (is In (from) (sites Start (piece (what at:(from)))))
        ("DoubleStepForwardToEmpty" "SetEnPassantLocation")
    )
)

//------------------------------------------------------------------------------

(game "Safe Passage" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn"
            (or 
                "InitialPawnMove"
                "EnPassant"
            )
            (then 
                (and
                    ("ReplayInMovingOn" (sites Mover "Promotion"))
                    (set Counter)
                )
            )
        )
        ("ChessRook" "Rook" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessKing" "King" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessBishop" "Bishop" (then (set Counter)))
        ("ChessKnight" "Knight" (then (set Counter)))
        ("ChessQueen" "Queen" (then (set Counter)))
        
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1) 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (do 
                    (or 
                        (forEach Piece)
                        ("Castling")
                    )
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
            )
        )
        
        (end {
            (if (is Threatened) (result All Loss)) 
            (if (and ("IsPieceAt" "King" P2 4) ("IsPieceAt" "King" P1 60)) (result All Win))
        })
    )
)

//------------------------------------------------------------------------------

(metadata 
    (info
        {
        (description "Safe Passage is a Chess puzzle created by Matthew Stephenson, inspired by the Safe Passage puzzle created by Karen Robinson.")
        (rules "This Chess puzzle uses the same rules as Chess. To win this puzzle you have to swap the positions of the kings. However, if at any point it is possible to capture a piece, you lose.")
        (source "inspired by the puzzle presented here: <a href=\"https://www.chessvariants.com/rules/safe-passage\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />chessvariants.com</a>")
        (id "459")
        (version "1.3.12")
        (classification "puzzle/planning")
        (author "Matthew Stephenson")
        }
    )
    
    (graphics {
        (show Check "King")
        (piece Scale "Pawn" 0.825)
        (piece Families {"Defined" "Microsoft" "Pragmata" "Symbola"})
        (board Style Chess)
    })
    
    (ai
        "Safe Passage_ai"
    )
)
