(define "MultiplicationWithDistance" 
    (= 
        (value Piece at:(to) level:0)
        (* (value Piece at:(from) level:(level)) (count Steps (from) (to)))
    )
)

(define "DivisionWithDistance" 
    (= 
        (value Piece at:(to) level:0)
        (/ (value Piece at:(from) level:(level)) (count Steps (from) (to)))
    )
)

(define "Addition"
    (!= 0 
        (count Sites 
            in:(forEach (sites Occupied by:Mover) 
                if:(and {
                    (!= (from) (site))
                    (is In (to)
                        (sites To
                            (forEach Level (site) FromBottom
                                (if (= (what at:(site) level:(level)) (id "Disc" Mover))
                                    (step (from (site) level:(level)) Orthogonal (to if:(not ("IsFriendAt" (to)))))
                                    (if (= (what at:(site) level:(level)) (id "Triangle" Mover))
                                        (slide (from (site) level:(level)) Diagonal 
                                            (between (exact 2) if:(is Empty (between)))
                                            (to if:("IsEnemyAt" (to)))
                                        )
                                        (if (= (what at:(site) level:(level)) (id "Square" Mover))
                                            (slide (from (site) level:(level)) Orthogonal 
                                                (between (exact 3) if:(is Empty (between)))
                                                (to if:("IsEnemyAt" (to)))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (= 
                        (value Piece at:(to) level:0)
                        (+ (value Piece at:(from) level:(level)) (value Piece at:(site)))
                    )
                })
            )
        )
    )
)

(define "Substraction"
    (!= 0 
        (count Sites 
            in:(forEach (sites Occupied by:Mover) 
                if:(and {
                    (!= (from) (site))
                    (is In (to)
                        (sites To
                            (forEach Level (site) FromBottom
                                (if (= (what at:(site) level:(level)) (id "Disc" Mover))
                                    (step (from (site) level:(level)) Orthogonal (to if:(not ("IsFriendAt" (to)))))
                                    (if (= (what at:(site) level:(level)) (id "Triangle" Mover))
                                        (slide (from (site) level:(level)) Diagonal 
                                            (between (exact 2) if:(is Empty (between)))
                                            (to if:("IsEnemyAt" (to)))
                                        )
                                        (if (= (what at:(site) level:(level)) (id "Square" Mover))
                                            (slide (from (site) level:(level)) Orthogonal 
                                                (between (exact 3) if:(is Empty (between)))
                                                (to if:("IsEnemyAt" (to)))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (= 
                        (value Piece at:(to) level:0)
                        (abs (- (value Piece at:(from) level:(level)) (value Piece at:(site))))
                    )
                })
            )
        )
    )
)

(define "Multiplication"
    (!= 0 
        (count Sites 
            in:(forEach (sites Occupied by:Mover) 
                if:(and {
                    (!= (from) (site))
                    (is In (to)
                        (sites To
                            (forEach Level (site) FromBottom
                                (if (= (what at:(site) level:(level)) (id "Disc" Mover))
                                    (step (from (site) level:(level)) Orthogonal (to if:(not ("IsFriendAt" (to)))))
                                    (if (= (what at:(site) level:(level)) (id "Triangle" Mover))
                                        (slide (from (site) level:(level)) Diagonal 
                                            (between (exact 2) if:(is Empty (between)))
                                            (to if:("IsEnemyAt" (to)))
                                        )
                                        (if (= (what at:(site) level:(level)) (id "Square" Mover))
                                            (slide (from (site) level:(level)) Orthogonal 
                                                (between (exact 3) if:(is Empty (between)))
                                                (to if:("IsEnemyAt" (to)))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (= 
                        (value Piece at:(to) level:0)
                        (* (value Piece at:(from) level:(level)) (value Piece at:(site)))
                    )
                })
            )
        )
    )
)

(define "Division"
    (!= 0 
        (count Sites 
            in:(forEach (sites Occupied by:Mover) 
                if:(and {
                    (!= (from) (site))
                    (is In (to)
                        (sites To
                            (forEach Level (site) FromBottom
                                (if (= (what at:(site) level:(level)) (id "Disc" Mover))
                                    (step (from (site) level:(level)) Orthogonal (to if:(not ("IsFriendAt" (to)))))
                                    (if (= (what at:(site) level:(level)) (id "Triangle" Mover))
                                        (slide (from (site) level:(level)) Diagonal 
                                            (between (exact 2) if:(is Empty (between)))
                                            (to if:("IsEnemyAt" (to)))
                                        )
                                        (if (= (what at:(site) level:(level)) (id "Square" Mover))
                                            (slide (from (site) level:(level)) Orthogonal 
                                                (between (exact 3) if:(is Empty (between)))
                                                (to if:("IsEnemyAt" (to)))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (or
                        (and
                            (!= 0 (value Piece at:(site)))
                            (= 
                                (value Piece at:(to))
                                (/ (value Piece at:(from) level:(level)) (value Piece at:(site)))
                            )
                        )
                        (and
                            (!= 0 (value Piece at:(from)))
                            (= 
                                (value Piece at:(to))
                                (/ (value Piece at:(site) level:(level)) (value Piece at:(from)))
                            )
                        )
                    )
                })
            )
        )
    )
)

(define "Encirclement"
    (and
        (!=
            (count Sites 
                in:(sites To
                    (if (= (what at:(site) level:(level)) (id "Disc" Next))
                        (step (from (site) level:(level)) Orthogonal (to if:("IsFriendAt" (to))))
                        (if (= (what at:(site) level:(level)) (id "Triangle" Next))
                            (slide (from (site) level:(level)) Diagonal 
                                (between (exact 2) if:(is Empty (between)))
                                (to 
                                    if:("IsFriendAt" (to))
                                    (apply if:("IsFriendAt" (to)))	
                                )
                            )
                            (if (= (what at:(site) level:(level)) (id "Square" Next))
                                (slide (from (site) level:(level)) Orthogonal 
                                    (between (exact 3) if:(is Empty (between)))
                                    (to 
                                        if:("IsFriendAt" (to))
                                        (apply if:("IsFriendAt" (to)))	
                                    )
                                )
                            )
                        )
                    )
                )
            )
            0
        )
        (=
            (count Sites 
                in:
                (sites To
                    (if (= (what at:(site) level:(level)) (id "Disc" Next))
                        (step (from (site) level:(level)) Orthogonal (to if:(or (is Empty (to)) ("IsEnemyAt" (to)))))
                        (if (= (what at:(site) level:(level)) (id "Triangle" Next))
                            (slide (from (site) level:(level)) Diagonal 
                                (between (exact 2) if:(is Empty (between)))
                                (to if:("IsEnemyAt" (to)))
                            )
                            (if (= (what at:(site) level:(level)) (id "Square" Next))
                                (slide (from (site) level:(level)) Orthogonal 
                                    (between (exact 3) if:(is Empty (between)))
                                    (to if:("IsEnemyAt" (to)))
                                )
                            )
                        )
                    )
                )
            )
            0
        )
    )
)

(define "CaptureConditions"
    (or {
        ("MultiplicationWithDistance")
        ("DivisionWithDistance")
        ("Addition")
        ("Substraction")
        ("Multiplication")
        ("Division")
    })
)

(define "NoStackedPiece" 
    (all Sites (sites Occupied by:#1) if:(= 1 (size Stack at:(site))))
)

(define "ArithmeticProgression"
    (if (is In (last To) (sites Next))
        (or {
            // N S
            (if (and (!= (ahead (last To) N) (last To)) (!= (ahead (last To) S) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) N))) 
                    (is Mover (who at:(ahead (last To) S)))
                    (is In (ahead (last To) N) (sites Next))
                    (is In (ahead (last To) S) (sites Next))
                    (= 
                        (abs (- (value Piece at:(ahead (last To) N)) (value Piece at:(last To))))
                        (abs (- (value Piece at:(ahead (last To) S)) (value Piece at:(last To))))
                    )
                })
            )
            (if (and (!= (ahead (last To) N) (last To)) (!= (ahead (last To) steps:2 N) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) N))) 
                    (is Mover (who at:(ahead (last To) steps:2 N)))
                    (is In (ahead (last To) N) (sites Next))
                    (is In (ahead (last To) steps:2 N) (sites Next))
                    (= 
                        (abs (- (value Piece at:(ahead (last To) N)) (value Piece at:(last To))))
                        (abs (- (value Piece at:(ahead (last To) steps:2 N)) (value Piece at:(ahead (last To) N))))
                    )
                })
            )
            (if (and (!= (ahead (last To) S) (last To)) (!= (ahead (last To) steps:2 S) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) S))) 
                    (is Mover (who at:(ahead (last To) steps:2 S)))
                    (is In (ahead (last To) S) (sites Next))
                    (is In (ahead (last To) steps:2 S) (sites Next))
                    (= 
                        (abs (- (value Piece at:(ahead (last To) S)) (value Piece at:(last To))))
                        (abs (- (value Piece at:(ahead (last To) steps:2 S)) (value Piece at:(ahead (last To) S))))
                    )
                })
            )
            
            // E W
            (if (and (!= (ahead (last To) E) (last To)) (!= (ahead (last To) W) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) E))) 
                    (is Mover (who at:(ahead (last To) W)))
                    (is In (ahead (last To) E) (sites Next))
                    (is In (ahead (last To) W) (sites Next))
                    (= 
                        (abs (- (value Piece at:(ahead (last To) E)) (value Piece at:(last To))))
                        (abs (- (value Piece at:(ahead (last To) W)) (value Piece at:(last To))))
                    )
                })
            )
            (if (and (!= (ahead (last To) E) (last To)) (!= (ahead (last To) steps:2 E) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) E))) 
                    (is Mover (who at:(ahead (last To) steps:2 E)))
                    (is In (ahead (last To) E) (sites Next))
                    (is In (ahead (last To) steps:2 E) (sites Next))
                    (= 
                        (abs (- (value Piece at:(ahead (last To) E)) (value Piece at:(last To))))
                        (abs (- (value Piece at:(ahead (last To) steps:2 E)) (value Piece at:(ahead (last To) E))))
                    )
                })
            )
            (if (and (!= (ahead (last To) W) (last To)) (!= (ahead (last To) steps:2 W) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) W))) 
                    (is Mover (who at:(ahead (last To) steps:2 W)))
                    (is In (ahead (last To) W) (sites Next))
                    (is In (ahead (last To) steps:2 W) (sites Next))
                    (= 
                        (abs (- (value Piece at:(ahead (last To) W)) (value Piece at:(last To))))
                        (abs (- (value Piece at:(ahead (last To) steps:2 W)) (value Piece at:(ahead (last To) W))))
                    )
                })
            )
            
            // NE SW
            (if (and (!= (ahead (last To) NE) (last To)) (!= (ahead (last To) SW) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) NE))) 
                    (is Mover (who at:(ahead (last To) SW)))
                    (is In (ahead (last To) NE) (sites Next))
                    (is In (ahead (last To) SW) (sites Next))
                    (= 
                        (abs (- (value Piece at:(ahead (last To) NE)) (value Piece at:(last To))))
                        (abs (- (value Piece at:(ahead (last To) SW)) (value Piece at:(last To))))
                    )
                })
            )
            (if (and (!= (ahead (last To) NE) (last To)) (!= (ahead (last To) steps:2 NE) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) NE))) 
                    (is Mover (who at:(ahead (last To) steps:2 NE)))
                    (is In (ahead (last To) NE) (sites Next))
                    (is In (ahead (last To) steps:2 NE) (sites Next))
                    (= 
                        (abs (- (value Piece at:(ahead (last To) NE)) (value Piece at:(last To))))
                        (abs (- (value Piece at:(ahead (last To) steps:2 NE)) (value Piece at:(ahead (last To) NE))))
                    )
                })
            )
            (if (and (!= (ahead (last To) SW) (last To)) (!= (ahead (last To) steps:2 SW) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) SW))) 
                    (is Mover (who at:(ahead (last To) steps:2 SW)))
                    (is In (ahead (last To) SW) (sites Next))
                    (is In (ahead (last To) steps:2 SW) (sites Next))
                    (= 
                        (abs (- (value Piece at:(ahead (last To) SW)) (value Piece at:(last To))))
                        (abs (- (value Piece at:(ahead (last To) steps:2 SW)) (value Piece at:(ahead (last To) SW))))
                    )
                })
            )
            
            // SE NW
            (if (and (!= (ahead (last To) SE) (last To)) (!= (ahead (last To) NW) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) SE))) 
                    (is Mover (who at:(ahead (last To) NW)))
                    (is In (ahead (last To) SE) (sites Next))
                    (is In (ahead (last To) NW) (sites Next))
                    (= 
                        (abs (- (value Piece at:(ahead (last To) SE)) (value Piece at:(last To))))
                        (abs (- (value Piece at:(ahead (last To) NW)) (value Piece at:(last To))))
                    )
                })
            )
            (if (and (!= (ahead (last To) SE) (last To)) (!= (ahead (last To) steps:2 SE) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) SE))) 
                    (is Mover (who at:(ahead (last To) steps:2 SE)))
                    (is In (ahead (last To) SE) (sites Next))
                    (is In (ahead (last To) steps:2 SE) (sites Next))
                    (= 
                        (abs (- (value Piece at:(ahead (last To) SE)) (value Piece at:(last To))))
                        (abs (- (value Piece at:(ahead (last To) steps:2 SE)) (value Piece at:(ahead (last To) SE))))
                    )
                })
            )
            (if (and (!= (ahead (last To) NW) (last To)) (!= (ahead (last To) steps:2 NW) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) NW))) 
                    (is Mover (who at:(ahead (last To) steps:2 NW)))
                    (is In (ahead (last To) NW) (sites Next))
                    (is In (ahead (last To) steps:2 NW) (sites Next))
                    (= 
                        (abs (- (value Piece at:(ahead (last To) NW)) (value Piece at:(last To))))
                        (abs (- (value Piece at:(ahead (last To) steps:2 NW)) (value Piece at:(ahead (last To) NW))))
                    )
                })
            )
        })
    )
)

(define "GeometricProgression"
    (if (is In (last To) (sites Next))
        (or {
            // N S
            (if (and (!= (ahead (last To) N) (last To)) (!= (ahead (last To) S) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) N))) 
                    (is Mover (who at:(ahead (last To) S)))
                    (is In (ahead (last To) N) (sites Next))
                    (is In (ahead (last To) S) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) S)))
                    (= 
                        (/ (value Piece at:(ahead (last To) N)) (value Piece at:(last To)))
                        (/ (value Piece at:(last To)) (value Piece at:(ahead (last To) S)))
                    )
                })
            )
            (if (and (!= (ahead (last To) N) (last To)) (!= (ahead (last To) steps:2 N) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) N))) 
                    (is Mover (who at:(ahead (last To) steps:2 N)))
                    (is In (ahead (last To) N) (sites Next))
                    (is In (ahead (last To) steps:2 N) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) N)))
                    (= 
                        (/ (value Piece at:(ahead (last To) N)) (value Piece at:(last To)))
                        (/ (value Piece at:(ahead (last To) steps:2 N)) (value Piece at:(ahead (last To) N)))
                    )
                })
            )
            (if (and (!= (ahead (last To) S) (last To)) (!= (ahead (last To) steps:2 S) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) S))) 
                    (is Mover (who at:(ahead (last To) steps:2 S)))
                    (is In (ahead (last To) S) (sites Next))
                    (is In (ahead (last To) steps:2 S) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) S)))
                    (= 
                        (/ (value Piece at:(ahead (last To) S)) (value Piece at:(last To)))
                        (/ (value Piece at:(ahead (last To) steps:2 S)) (value Piece at:(ahead (last To) S)))
                    )
                })
            )
            
            // E W
            (if (and (!= (ahead (last To) E) (last To)) (!= (ahead (last To) W) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) E))) 
                    (is Mover (who at:(ahead (last To) W)))
                    (is In (ahead (last To) E) (sites Next))
                    (is In (ahead (last To) W) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) W)))
                    (= 
                        (/ (value Piece at:(ahead (last To) E)) (value Piece at:(last To)))
                        (/ (value Piece at:(last To)) (value Piece at:(ahead (last To) W)))
                    )
                })
            )
            (if (and (!= (ahead (last To) E) (last To)) (!= (ahead (last To) steps:2 E) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) E))) 
                    (is Mover (who at:(ahead (last To) steps:2 E)))
                    (is In (ahead (last To) E) (sites Next))
                    (is In (ahead (last To) steps:2 E) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) E)))
                    (= 
                        (/ (value Piece at:(ahead (last To) E)) (value Piece at:(last To)))
                        (/ (value Piece at:(ahead (last To) steps:2 E)) (value Piece at:(ahead (last To) E)))
                    )
                })
            )
            (if (and (!= (ahead (last To) W) (last To)) (!= (ahead (last To) steps:2 W) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) W))) 
                    (is Mover (who at:(ahead (last To) steps:2 W)))
                    (is In (ahead (last To) W) (sites Next))
                    (is In (ahead (last To) steps:2 W) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) W)))
                    (= 
                        (/ (value Piece at:(ahead (last To) W)) (value Piece at:(last To)))
                        (/ (value Piece at:(ahead (last To) steps:2 W)) (value Piece at:(ahead (last To) W)))
                    )
                })
            )
            
            // NE SW
            (if (and (!= (ahead (last To) NE) (last To)) (!= (ahead (last To) SW) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) NE))) 
                    (is Mover (who at:(ahead (last To) SW)))
                    (is In (ahead (last To) NE) (sites Next))
                    (is In (ahead (last To) SW) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) SW)))
                    (= 
                        (/ (value Piece at:(ahead (last To) NE)) (value Piece at:(last To)))
                        (/ (value Piece at:(last To)) (value Piece at:(ahead (last To) SW)))
                    )
                })
            )
            (if (and (!= (ahead (last To) NE) (last To)) (!= (ahead (last To) steps:2 NE) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) NE))) 
                    (is Mover (who at:(ahead (last To) steps:2 NE)))
                    (is In (ahead (last To) NE) (sites Next))
                    (is In (ahead (last To) steps:2 NE) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) NE)))
                    (= 
                        (/ (value Piece at:(ahead (last To) NE)) (value Piece at:(last To)))
                        (/ (value Piece at:(ahead (last To) steps:2 NE)) (value Piece at:(ahead (last To) NE)))
                    )
                })
            )
            (if (and (!= (ahead (last To) SW) (last To)) (!= (ahead (last To) steps:2 SW) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) SW))) 
                    (is Mover (who at:(ahead (last To) steps:2 SW)))
                    (is In (ahead (last To) SW) (sites Next))
                    (is In (ahead (last To) steps:2 SW) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) SW)))
                    (= 
                        (/ (value Piece at:(ahead (last To) SW)) (value Piece at:(last To)))
                        (/ (value Piece at:(ahead (last To) steps:2 SW)) (value Piece at:(ahead (last To) SW)))
                    )
                })
            )
            
            // SE NW
            (if (and (!= (ahead (last To) SE) (last To)) (!= (ahead (last To) NW) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) SE))) 
                    (is Mover (who at:(ahead (last To) NW)))
                    (is In (ahead (last To) SE) (sites Next))
                    (is In (ahead (last To) NW) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) NW)))
                    (= 
                        (/ (value Piece at:(ahead (last To) SE)) (value Piece at:(last To)))
                        (/ (value Piece at:(last To)) (value Piece at:(ahead (last To) NW)))
                    )
                })
            )
            (if (and (!= (ahead (last To) SE) (last To)) (!= (ahead (last To) steps:2 SE) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) SE))) 
                    (is Mover (who at:(ahead (last To) steps:2 SE)))
                    (is In (ahead (last To) SE) (sites Next))
                    (is In (ahead (last To) steps:2 SE) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) SE)))
                    (= 
                        (/ (value Piece at:(ahead (last To) SE)) (value Piece at:(last To)))
                        (/ (value Piece at:(ahead (last To) steps:2 SE)) (value Piece at:(ahead (last To) SE)))
                    )
                })
            )
            (if (and (!= (ahead (last To) NW) (last To)) (!= (ahead (last To) steps:2 NW) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) NW))) 
                    (is Mover (who at:(ahead (last To) steps:2 NW)))
                    (is In (ahead (last To) NW) (sites Next))
                    (is In (ahead (last To) steps:2 NW) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) NW)))
                    (= 
                        (/ (value Piece at:(ahead (last To) NW)) (value Piece at:(last To)))
                        (/ (value Piece at:(ahead (last To) steps:2 NW)) (value Piece at:(ahead (last To) NW)))
                    )
                })
            )
        })
    )
)

(define "HarmonicProgression"
    (if (is In (last To) (sites Next))
        (or {
            // N S
            (if (and (!= (ahead (last To) N) (last To)) (!= (ahead (last To) S) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) N))) 
                    (is Mover (who at:(ahead (last To) S)))
                    (is In (ahead (last To) N) (sites Next))
                    (is In (ahead (last To) S) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) S)))
                    (= 
                        (/ (value Piece at:(ahead (last To) N)) (value Piece at:(last To)))
                        (/ (value Piece at:(last To)) (value Piece at:(ahead (last To) S)))
                    )
                })
            )
            (if (and (!= (ahead (last To) N) (last To)) (!= (ahead (last To) steps:2 N) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) N))) 
                    (is Mover (who at:(ahead (last To) steps:2 N)))
                    (is In (ahead (last To) N) (sites Next))
                    (is In (ahead (last To) steps:2 N) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) N)))
                    (= 
                        (/ (value Piece at:(ahead (last To) N)) (value Piece at:(last To)))
                        (/ (value Piece at:(ahead (last To) steps:2 N)) (value Piece at:(ahead (last To) N)))
                    )
                })
            )
            (if (and (!= (ahead (last To) S) (last To)) (!= (ahead (last To) steps:2 S) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) S))) 
                    (is Mover (who at:(ahead (last To) steps:2 S)))
                    (is In (ahead (last To) S) (sites Next))
                    (is In (ahead (last To) steps:2 S) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) S)))
                    (= 
                        (/ (value Piece at:(ahead (last To) S)) (value Piece at:(last To)))
                        (/ (value Piece at:(ahead (last To) steps:2 S)) (value Piece at:(ahead (last To) S)))
                    )
                })
            )
            
            // E W
            (if (and (!= (ahead (last To) E) (last To)) (!= (ahead (last To) W) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) E))) 
                    (is Mover (who at:(ahead (last To) W)))
                    (is In (ahead (last To) E) (sites Next))
                    (is In (ahead (last To) W) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) W)))
                    (= 
                        (/ (value Piece at:(ahead (last To) E)) (value Piece at:(last To)))
                        (/ (value Piece at:(last To)) (value Piece at:(ahead (last To) W)))
                    )
                })
            )
            (if (and (!= (ahead (last To) E) (last To)) (!= (ahead (last To) steps:2 E) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) E))) 
                    (is Mover (who at:(ahead (last To) steps:2 E)))
                    (is In (ahead (last To) E) (sites Next))
                    (is In (ahead (last To) steps:2 E) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) E)))
                    (= 
                        (/ (value Piece at:(ahead (last To) E)) (value Piece at:(last To)))
                        (/ (value Piece at:(ahead (last To) steps:2 E)) (value Piece at:(ahead (last To) E)))
                    )
                })
            )
            (if (and (!= (ahead (last To) W) (last To)) (!= (ahead (last To) steps:2 W) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) W))) 
                    (is Mover (who at:(ahead (last To) steps:2 W)))
                    (is In (ahead (last To) W) (sites Next))
                    (is In (ahead (last To) steps:2 W) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) W)))
                    (= 
                        (/ (value Piece at:(ahead (last To) W)) (value Piece at:(last To)))
                        (/ (value Piece at:(ahead (last To) steps:2 W)) (value Piece at:(ahead (last To) W)))
                    )
                })
            )
            
            // NE SW
            (if (and (!= (ahead (last To) NE) (last To)) (!= (ahead (last To) SW) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) NE))) 
                    (is Mover (who at:(ahead (last To) SW)))
                    (is In (ahead (last To) NE) (sites Next))
                    (is In (ahead (last To) SW) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) SW)))
                    (= 
                        (/ (value Piece at:(ahead (last To) NE)) (value Piece at:(last To)))
                        (/ (value Piece at:(last To)) (value Piece at:(ahead (last To) SW)))
                    )
                })
            )
            (if (and (!= (ahead (last To) NE) (last To)) (!= (ahead (last To) steps:2 NE) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) NE))) 
                    (is Mover (who at:(ahead (last To) steps:2 NE)))
                    (is In (ahead (last To) NE) (sites Next))
                    (is In (ahead (last To) steps:2 NE) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) NE)))
                    (= 
                        (/ (value Piece at:(ahead (last To) NE)) (value Piece at:(last To)))
                        (/ (value Piece at:(ahead (last To) steps:2 NE)) (value Piece at:(ahead (last To) NE)))
                    )
                })
            )
            (if (and (!= (ahead (last To) SW) (last To)) (!= (ahead (last To) steps:2 SW) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) SW))) 
                    (is Mover (who at:(ahead (last To) steps:2 SW)))
                    (is In (ahead (last To) SW) (sites Next))
                    (is In (ahead (last To) steps:2 SW) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) SW)))
                    (= 
                        (/ (value Piece at:(ahead (last To) SW)) (value Piece at:(last To)))
                        (/ (value Piece at:(ahead (last To) steps:2 SW)) (value Piece at:(ahead (last To) SW)))
                    )
                })
            )
            
            // SE NW
            (if (and (!= (ahead (last To) SE) (last To)) (!= (ahead (last To) NW) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) SE))) 
                    (is Mover (who at:(ahead (last To) NW)))
                    (is In (ahead (last To) SE) (sites Next))
                    (is In (ahead (last To) NW) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) NW)))
                    (= 
                        (/ (value Piece at:(ahead (last To) SE)) (value Piece at:(last To)))
                        (/ (value Piece at:(last To)) (value Piece at:(ahead (last To) NW)))
                    )
                })
            )
            (if (and (!= (ahead (last To) SE) (last To)) (!= (ahead (last To) steps:2 SE) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) SE))) 
                    (is Mover (who at:(ahead (last To) steps:2 SE)))
                    (is In (ahead (last To) SE) (sites Next))
                    (is In (ahead (last To) steps:2 SE) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) SE)))
                    (= 
                        (/ (value Piece at:(ahead (last To) SE)) (value Piece at:(last To)))
                        (/ (value Piece at:(ahead (last To) steps:2 SE)) (value Piece at:(ahead (last To) SE)))
                    )
                })
            )
            (if (and (!= (ahead (last To) NW) (last To)) (!= (ahead (last To) steps:2 NW) (last To)))
                (and {
                    (is Mover (who at:(ahead (last To) NW))) 
                    (is Mover (who at:(ahead (last To) steps:2 NW)))
                    (is In (ahead (last To) NW) (sites Next))
                    (is In (ahead (last To) steps:2 NW) (sites Next))
                    (!= 0 (value Piece at:(last To)))
                    (!= 0 (value Piece at:(ahead (last To) NW)))
                    (= 
                        (/ (value Piece at:(ahead (last To) NW)) (value Piece at:(last To)))
                        (/ (value Piece at:(ahead (last To) steps:2 NW)) (value Piece at:(ahead (last To) NW)))
                    )
                })
            )
        })
    )
)

(define "MathematicalProgressionAlignementOpponentSide"
    (or {
        ("ArithmeticProgression")
        ("GeometricProgression")
        ("HarmonicProgression")
    })
)

//------------------------------------------------------------------------------

(game "Rithmomachia"
    (players 2)
    (equipment {
        (board (rectangle 16 8))
        (piece "Square" Each
            (move Slide Orthogonal
                (between (exact 3) if:(is Empty (between)))
                (to
                    if:(and ("IsEnemyAt" (to)) ("CaptureConditions"))
                    (apply 
                        (if 
                            ("IsEnemyAt" (to)) 
                            (forEach Level (to) FromTop
                                (remove (to) level:(level))
                            )
                        )
                    )		
                )
                stack:True
            )		
        )
        (piece "Triangle" Each
            (move Slide Diagonal
                (between (exact 2) if:(is Empty (between)))
                (to
                    if:(and ("IsEnemyAt" (to)) ("CaptureConditions"))
                    (apply
                        (if ("IsEnemyAt" (to)) 
                            (forEach Level (to) FromTop
                                (remove (to) level:(level))
                            )
                        )
                    )		
                )
                stack:True
            )
        )
        (piece "Disc" Each
            (move Step Orthogonal
                (to 
                    if:(if ("IsEnemyAt" (to)) ("CaptureConditions") (is Empty (to)))
                    (apply 
                        (if ("IsEnemyAt" (to)) 
                            (forEach Level (to) FromTop
                                (remove (to) level:(level))
                            )
                        )
                    )		
                )
                stack:True
            )
        )
        (regions P1 (expand (sites Bottom) steps:7))
        (regions P2 (expand (sites Top) steps:7))
    })
    (rules 
        (start {
            (place "Square1" coord:"A1" value:289) 
            (place "Square1" coord:"B1" value:169) 
            (place "Square1" coord:"G1" value:81) 
            (place "Square1" coord:"H1" value:25) 
            (place "Square1" coord:"A2" value:153) 
            (place "Square1" coord:"G2" value:45) 
            (place "Square1" coord:"H2" value:15) 
            
            (place "Triangle1" coord:"G3" value:6) 
            (place "Triangle1" coord:"E2" value:20) 
            (place "Triangle1" coord:"D2" value:42) 
            (place "Triangle1" coord:"B3" value:72) 
            (place "Triangle1" coord:"H3" value:9) 
            (place "Triangle1" coord:"F2" value:25) 
            (place "Triangle1" coord:"C2" value:49) 
            (place "Triangle1" coord:"A3" value:81) 
            
            (place "Disc1" coord:"F4" value:2) 
            (place "Disc1" coord:"E4" value:4) 
            (place "Disc1" coord:"F3" value:4) 
            (place "Disc1" coord:"D4" value:6) 
            (place "Disc1" coord:"C4" value:8) 
            (place "Disc1" coord:"E3" value:16) 
            (place "Disc1" coord:"D3" value:36) 
            (place "Disc1" coord:"C3" value:64) 
            
            (place "Square2" coord:"H16" value:361) 
            (place "Square2" coord:"G16" value:225) 
            (place "Square2" coord:"B16" value:121) 
            (place "Square2" coord:"A16" value:49) 
            (place "Square2" coord:"G15" value:120) 
            (place "Square2" coord:"B15" value:66) 
            (place "Square2" coord:"A15" value:28) 
            
            (place "Triangle2" coord:"B14" value:12) 
            (place "Triangle2" coord:"D15" value:30) 
            (place "Triangle2" coord:"E15" value:56) 
            (place "Triangle2" coord:"G14" value:90) 
            (place "Triangle2" coord:"A14" value:16) 
            (place "Triangle2" coord:"C15" value:36) 
            (place "Triangle2" coord:"F15" value:64) 
            (place "Triangle2" coord:"H14" value:100) 
            
            (place "Disc2" coord:"C13" value:3) 
            (place "Disc2" coord:"D13" value:5) 
            (place "Disc2" coord:"E13" value:7) 
            (place "Disc2" coord:"F13" value:9) 
            (place "Disc2" coord:"C14" value:9) 
            (place "Disc2" coord:"D14" value:25) 
            (place "Disc2" coord:"E14" value:49) 
            (place "Disc2" coord:"F14" value:81) 
            
            (place Stack "Square1" 9 value:36)
            (place Stack "Square1" 9 value:25)
            (place Stack "Triangle1" 9 value:16)
            (place Stack "Triangle1" 9 value:9)
            (place Stack "Disc1" 9 value:4)
            (place Stack "Disc1" 9 value:1)
            
            (place Stack "Square2" 119 value:64)
            (place Stack "Square2" 119 value:49)
            (place Stack "Triangle2" 119 value:36)
            (place Stack "Triangle2" 119 value:25)
            (place Stack "Disc2" 119 value:16)
        })
        (play
            (or
                (forEach Piece)
                (forEach Site (sites Occupied by:Next)
                    (forEach Level (site) FromBottom
                        (if 
                            ("Encirclement")
                            (move Remove (site) level:(level))
                        )
                    )
                )
            )
        )
        (end (if 
                (and
                    ("MathematicalProgressionAlignementOpponentSide") 
                    ("NoStackedPiece" Next)
                )
                (result Mover Win)
            )
        )
    )
)

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Rithmomachia is a mathematical game of capture played in medieval and early modern Europe. Its complex mathematical rules suggest that it was originally only played in learned circles. There are many treatises and fragments of the rules, which suggest several variations on the rules through time.")
        (aliases {"Rithmomachy" "Ludus Philosophorum" "Philosopher's GameRithmachia" "Philosopher's Table" "Rutimachie" "Rithmimachie" "Ryghtmadhye"})
        (rules "8x16 board. Two players, one black, one white. Each player has three types of pieces: Circles, triangle, squares, and one pyramid made up of multiple pieces stacked. Circles move one space orthogonally. Triangles move two spaces diagonally. Squares move three spaces orthogonally. Pyramids may move in any of the directions allowed by one of its constituent pieces. Each piece has a number. For white—circles: 2, 4, 6, 8, 4, 16, 36, 64; triangles: 6, 20 , 42, 72, 9, 25, 49, 81; squares: 15, 45, 153, 25, 81, 169, 289; pyramid (91) from the base: square 36, square 25, triangle 16, triangle 9, circle 4, circle 1. For black—circles: 3, 5, 7, 9, 9, 25, 49, 81; triangles: 12, 30, 56, 90, 16, 36, 64, 100; squares: 28, 66, 120, 49, 121, 225, 361; pyramid (190): from the base: square 64, square 49, triangle 36, triangle 25, circle 16. 
            
            Pieces capture other pieces by mathematical allowances based on the numbers on the pieces. There are nine scenarios in which pieces can be taken when a piece moves to a space occupied by an opponent's piece. 
            
            Multiplication with distance: If the value of the piece to be taken equals the value of the piece making the capture multiplied by the distance between the two pieces; 
            
            Division by distance: If the value of the piece to be taken equals the value of the piece making the capture divided by the distance between the pieces. 
            
            Addition: When two pieces can both move to the space of an opponent's piece, if the sum of the two pieces equals the value of the opponent's piece, it is captured and the player chooses which piece to move to that space. 
            
            Subtraction: When two pieces can both move to the space of an opponent's piece, if the difference between the value of these pieces equals the value of the opponent's piece, it is taken, and the player chooses which piece to move to the space. 
            
            Multiplication: When two pieces can both move to the space of an opponent's piece, if the product of the values of the two pieces equals the value of the opponent's piece, it is taken and the player chooses which piece to move to the space. 
            
            Division: When two pieces can both move to the space of an opponent's piece, if the quotient of the values of the two pieces equals the value of the opponent's piece, it is taken and the player chooses which piece to move to the space.
            
            Encirclement: If pieces are positioned such that there is no possible move or capture for the opponent's piece, the opponent's piece is taken.
            
            Pyramid capture: A pyramid can be captured by capturing its constituent pieces one-by-one according to the above methods; by encircling it so it cannot move, or by obtaining the sum of the constituent pieces or of its base pieces according to the above rules; A pyramid captures as a single one of its component pieces according to the above rules (the direction of the move is independent of the value chosen), or by using the sum of its pieces according to the above rules.
            
        The goal of the game is to capture the opponent's pyramid and to create an alignment on the opponent's half of the board forming a mathematical progression. The progression may be arithmetic (a sequence where the difference between the values is constant), geometric (where each value after the first is determined by multiplying the previous value by a fixed number), or harmonic (1/a, 1/a+d, 1/a+2d, 1/a+3d). The pieces in the progression must be in a straight orthogonal or diagonal line or in a chevron shape, and must be equally spaced.")
        (source "Stigter 2007: 265-268.")
        (id "165")
        (version "1.3.5")
        (classification "board/war/replacement/eliminate/target")
        (credit "Eric Piette")
        }
    )
    
    (graphics {
        (stackType None)
        (piece Colour P2 secondaryColour:(colour White))
        (board Colour Phase0 (colour 223 178 110))
        (board Colour InnerEdges (colour Black))
        (board Colour OuterEdges (colour Black))
        (show Piece Value Middle scale:0.7 offsetX:0.3 offsetY:0.5)
    })
    
)

