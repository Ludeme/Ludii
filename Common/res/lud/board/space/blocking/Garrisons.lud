// Site definitions for scoring
(define "EmptyRegionPerimeter" (sites Around (sites Group at:(site) if:(is Empty (to)))))

(define "AllUnreachableSites"
    (difference
        (sites Board)
        (sites
            (union 
                {
                (values Remembered "R-P2")
                (values Remembered "R-P1")
                (values Remembered "RMax-P2")
                (values Remembered "RMax-P1")
                }
))))

(define "BlockedSites"   //sites
    (forEach 
        ("AllUnreachableSites")
        if:(and 
            (=
                (count Sites
                    in:(intersection
                        ("EmptyRegionPerimeter")
                        (sites State 2)
                ))
                (count Orthogonal at:(site))
            )
            (all Sites
                (sites Group at:(site) if:(is Empty (to)))
                if:(=
                    (count Sites in:(sites Around (site) if:(= 1 (who at:(to)))))
                    (count Sites in:(sites Around (site) if:(= 2 (who at:(to)))))
)))))

//------------------------
// Utilities
//Mappings

(define "OpponentOf" (- 3 #1))

// Booleans

(define "IsPlaceableByAt" // (mover) (next)
    (> 
        (+
            (count Pieces of:#1 in:(sites Around #2))
            (count Pieces of:#1
                in:(sites Around #2 if:(= 2 (state at:(to))))
        ))
        (+
            (count Pieces of:("OpponentOf" #1) in:(sites Around #2 includeSelf:True))
            (count Pieces of:("OpponentOf" #1)
                in:(sites Around #2 if:(= 2 (state at:(to))) includeSelf:True)
))))

(define "MaintainsContact"  // The original location must be treated as empty.
    (not
        (no Pieces
            in:(difference
                (intersection
                    (sites Around (from) Orthogonal)
                    (sites Around (to) Orthogonal)
                )
                (var "LF")
))))

// the moving piece dynamically affects the territory count.  
(define "CanSkirtTo" // for mover during move
    (and 
        ("MaintainsContact")
        (>=
            (+ 
                {
                (if (is In (var "LF") (sites Around (from))) 0 1)   // For the moving piece without double counting at origin
                (count Pieces of:(mover)
                    in:(sites Around (from))
                )
                (count Pieces of:(mover)
                    in:(sites Around (from) if:(= 2 (state at:(to))))
                )
                }
            )
            (+
                (count Pieces of:(next)
                    in:(sites Around (from))
                )
                (count Pieces of:(next)
                    in:(sites Around (from) if:(= 2 (state at:(to))))
)))))

//------------------------------------------
// Moves
(define "Placement"
    (move Add 
        (piece (id "Disc" Mover))
        (to 
            (sites Empty)
            if:("IsPlaceableByAt" (mover) (to))
            (apply (set State at:(to) 1))
)))

(define "Skirting"
    (forEach Piece 
        (do
            (set Var "LF" (from))
            next:(if
                (= 1 (state at:(from)))
                (move
                    (from)
                    (to
                        (sites Empty) 
                        if:(!= Infinity
                            (count Steps Orthogonal
                                (step Orthogonal
                                    (to
                                        if:(and
                                            (is Empty (from)) 
                                            ("CanSkirtTo")
                                ))) 
                                (to) 
                                (var "LF") // switch direction to test 
                ))))
                (then
                    (set Var "SkirtCount" (+ (var "SkirtCount") 1)
                        (then (set State at:(last To) 2))
                ))
)))) 

(define  "PieRefusal" 
    (move Swap Players 1 2
        (then
            (set Var "Offerer" 2)
)))

(define "Place3rdPiePiece"
    (move Add (piece (next)) 
        (to (sites Empty) (apply (set State at:(to) 1)))
    )
    (then (set Var "Offerer" 1))
)

(define "PlacePiePiece"
    (move Add (to (sites Empty) (apply (set State at:(to) 1)))
        (then
            (seq
                {
                (set Value P1 0)
                (set Value P2 0)
                (set Var "SkirtCount" 0)
                (set Var "PlacementCount" 0)
                (moveAgain)
                }
))))

//-------------------
// Game structure

(define "MoveOrPlace"
    (do
        (if
            ("NewTurn")
            (and 
                (set Var "SkirtCount" 0)
                (set Var "PlacementCount" 0)
        ))
        next:(or
            ("Placement")
            ("Skirting")
        ) 
        (then 
            (set Var "PlacementCount"
                (+ 1 (var "PlacementCount")) 
                (then
                    (if
                        (>
                            <Moves:perTurn>
                            (var "PlacementCount")
                        )
                        (moveAgain)
))))))

(define "TheGame" 
    (if
        (= 1 (mover))
        (do
            (and
                (forget Value "R-P1" All) 
                (forget Value "RMax-P2" All)
            )
            next:"MoveOrPlace"  // ("OriginalGame") // ("TwoPlusOneSkirtGame")
        )
        (do
            (and
                (forget Value "R-P2" All) 
                (forget Value "RMax-P1" All)
            )
            next:"MoveOrPlace"  // ("OriginalGame") // ("TwoPlusOneSkirtGame")
)))

(define "WithPie"
    (if
        (> 2 (counter))
        (if
            (= -1 (counter))
            ("PlacePiePiece" 0)
            (if
                (= 0 (counter))
                ("PlacePiePiece" 1)
                ("Place3rdPiePiece")
        ))
        (or
            (if
                (= 2 (counter))
                ("PieRefusal")
            )
            ("TheGame")
        )
        (then
            ("Score")
        ) 
))

(define "WithoutPie"
    (if
        (> 1 (counter))
        (move Add
            (to (sites Empty)
                (apply (set State at:(to) 1))
            )
        )
        ("TheGame")
        (then
            ("Score")
))) 

(define "MoveTrigger" (% (+ 1 (var "PlacementCount")) #1))
//---------------------------------------
// Main routine
//---------------------------------------

(game "Garrisons"
    (players 2)
    (equipment
        {
        (board <Board:size> use:Vertex)
        (piece "Disc" Each)
        }
    )
    (rules 
        (play
            <Starting:method>  // "WithPie" / "WithoutPie"
        )
        (end 
            (if
                (and
                    (< 3 (counter))
                    (<
                        (- 
                            (count Vertices)
                            (var "CountOfBlockedSites") //set in the Scoring defines below
                        )
                        (max
                            (array
                                {
                                (* 2 (score P1))  // P1 win
                                (* 2 (score P2))  // P2 win
                                (+ {1 (score P1) (score P2)}) // Tie
                                }
                ))))
                (byScore)
))))

//----------------------------------------
// Scoring and End conditions
// Finding Reachable Sites for each player
// On a turn find the sites reachable considering everything as 1 stacks for the minimal case
// and the opponent's reachable sites considering all as 2 stacks for the maximal case.
// then subtract  the opponent's sites to get the mover's assured sites.

(define "CountOfPiecesOfAround"   // an integer  // arguments: <skirter:int>; <reachable sites so far> 
    // This is a work around for (count Pieces ... ) 
    // as iterator 'from' has distinct meaning in (count Steps (step ...))
    // and I need all pieces, not just sites.
    (+
        (count Sites
            in:(intersection
                (sites Occupied by:(player #1)) 
                (sites Around #2)
        ))
        (count Sites
            in:(intersection
                (sites Occupied by:(player #1)) 
                (sites Around #2 if:(= 2 (state at:(to))))
))))

// No placing can happen at sites where opponent has enough actual piece to foever block entry even using stacks 

(define "NotExcludedToSite" // boolean  // arguments: <Stack height:int>, <skirter:int>
    // This prevents including sites that could be blocked later in the game, from inclusion in the minimal list
    (or
        (!= 2 #1)
        (>
            (count Sites
                in:(sites Around #3
                    if:(not
                        (is In (to) (sites Occupied by:(player ("OpponentOf" #2))))
            )))
            (/ ("CountOfPiecesOfAround" ("OpponentOf" #2) #3) 2)
)))

(define "StepRestrictionForSkirting" // boolean // arguments: e.g.  "SitesSoFarOf" or (sites {(from)}), 1 <i.e. player index>, Stack height
    // This enforces the skirting movement destination influence requirement for sites to be added to the list using skirting. 
    (>=
        (+ 1 
            (- 
                (*
                    #3
                    (size Array
                        (array
                            (intersection #1
                                (difference
                                    (sites Around (from))
                                    (sites {(to)})
                )))))
                (if
                    (= 1 #3)
                    0
                    // subtract 1 fo each actual neighboring single
                    (size Array
                        (array
                            (difference
                                (sites Around (from)
                                    if:(and
                                        (is In (to) (sites Occupied by:(player #2)))
                                        (= 1 (state at:(to))) // restricted to real stacks of 1
                                ))
                                (sites {(to)}) // not counting the source site 
                                // from which the moving piece came
        ))))))
        ("CountOfPiecesOfAround" ("OpponentOf" #2) (from))
))

(define "AdjacencyRestrictionForSkirting"  // boolean // arguments:  e.g.  "SitesSoFarOf" or (sites {(from)})
    // This enforces the skirting movement adjacency requirement for sites to be added to the list using skirting.
    (< 0
        (count Sites 
            in:(intersection
                (sites Around (from)) 
                (sites Around (to)
                    if:(or
                        (not (is Empty (to))) 
                        (is In (to) #1)
))))))

(define "CanBeReachedBySkirting"  // boolean // arguments: e.g.  "SitesSoFarOf" or (sites {(from)}), 1 <i.e. player index> , Stack height
    // This enforces all the restrictions for finding sites that can be added to the list by Skirting
    (and
        {
        (or
            {    
            (is Empty (to)) // not yet traced back to source
            (and
                (is In (to) #1) // traced back to friendly potential source
                (!= 2 (state at:(to))) // that is not an existing stack
            )
            }
        )
        // Meets skirting restrictions
        ("AdjacencyRestrictionForSkirting" #1)  
        ("StepRestrictionForSkirting" #1 #2 #3)
        }
))

(define "AppendReachOf"  // boolean // arguments: e.g.  "R-P1", 1, ("SitesSoFarOf" "R-P1"), maxStack height
    // This adds reachable sites to the list for placements and for skirting, 
    // when enforcing all relavent restrictions 
    (forEach Site
        (difference (sites Empty) #3)
        (if
            (or
                // can be reached by placements where skirting is not possible
                (and
                    {
                    ("NotExcludedToSite" #4 #2 (site)) 
                    (>
                        (+
                            (* #4 (size Array (array (intersection #3 (sites Around (site))))))
                            (if
                                (= 1 #4)
                                // for use by "R-Pn"  with 2 stacks (#4 is 1 so that potential sites are assumed minimal) 
                                (count Pieces of:#2 in:(sites Around (site) if:(= 2 (state at:(to)))))
                                // for use by "RMax-Pn" with 2 stacks (#4 is 2 so that potential sites are assumed maximal)       
                                (- 0 (count Pieces of:#2 in:(sites Around (site) if:(= 1 (state at:(to))))))
                        ))
                        ("CountOfPiecesOfAround" ("OpponentOf" #2) (site))
                    )
                    }
                )
                (!=
                    Infinity
                    (count Steps
                        (step
                            (to      
                                if:(or
                                    { 
                                    // can be reached by placements where skirting is not possible
                                    (no Pieces in:(sites Around (from)))
                                    
                                    // can be reached by skirting
                                    ("CanBeReachedBySkirting" #3 #2 #4)
                                    }
                        )))
                        (site)
                        #3
            )))
            (remember Value #1 (site) unique:True)
        )
        
))

(define "SitesSoFarOf" (sites (values Remembered #1)))  // Readability aid

(define "ReachLoop" 
    // Starting with the piece locations as a basis, 
    // this loop adds sites to the reachable sites list until noe are left to add.
    (seq
        { 
        ("AppendReachOf" #1 #2 ("SitesSoFarOf" #1) #3)
        (while
            (>
                (size Array (values Remembered #1)) 
                (var #1)
            )
            (seq
                {
                (set Var #1 (size Array (values Remembered #1)))
                ("AppendReachOf" #1 #2 ("SitesSoFarOf" #1) #3)
                }  
        ))
        }
))

(define "RememberReachOf" // e.g.  "R-P1" or "RMax-1", <player>, stack height to consider  1 or 2
    // This regenerates the potential reach lists
    (forEach Site
        (sites Occupied by:(player #2))
        (remember Value #1 (site) unique:True) 
        (then
            (set Var #1 (size Array (values Remembered #1))
            (then ("ReachLoop" #1 #2 #3)))
)))

//-------------
// Find the territories (used for Scoring, display, and ending the game)

(define "BlockableSites" // <region> // args: Stack height, skirter
    // This lists the sites that could be become blocked later 
    // in order to exclude them from the players confirmed territory
    (forEach
        (sites Empty)
        if:(and 
            (=
                (count Orthogonal at:(site)) 
                ("CountOfPiecesOfAround" #1 (site))
            )
            (=
                (count Orthogonal at:(site))
                (* 2
                    (count Sites
                        in:(sites Around (site)
                            if:(is In (to) (sites (values Remembered #2)))
)))))))

(define "TerritoryOf" // <region> //args: 1 or 2
    // This defines territory as the difference between assured reachable sites
    // (i.e. from which potentially blockable sites have been excluded) 
    // and the opponent's maximal reachable sites
    
    (if
        (= 1 #1)
        (sites
            (difference
                (values Remembered "R-P1")
                (union
                    {
                    (array ("BlockableSites" #1 "RMax-P2"))
                    (values Remembered "RMax-P2")
                    }
        )))
        (sites
            (difference
                (values Remembered "R-P2")
                (union
                    {
                    (array ("BlockableSites" #1 "RMax-P1"))
                    (values Remembered "RMax-P1")
                    }
))))) 

//-------------------------------
// Main Territory update routines

(define "UpdateScore"  // subrountine to update territory and scores
    (do
        (seq
            {
            ("RememberReachOf" #1 #2 1)  // 1 for "R-"
            ("RememberReachOf" #3 #4 2)  // 2 for  "RMax-"
            }
        )
        next:(set Score (player #2)
            (size Array (array ("TerritoryOf" #2)))
)))

(define "Score" 
    // This drives the territory calculations for the appropriate player
    // Including making a count of the actual blocked sites as of the last turn
    (if
        (= 1 (mover))
        ("UpdateScore" "R-P1" 1 "RMax-P2" 2)  
        ("UpdateScore" "R-P2" 2 "RMax-P1" 1)
        (then
            (set Var "CountOfBlockedSites"
                (count Sites in:("BlockedSites")) // note: only updates after opponents turn, since RMax is not recalculated until then
))))

//------------------------------------------------------

//---------------------------------------

(define "Tri46Bug"  (tri {4 6 4 7 4}))
(define "Tri56Bug"  (tri {5 6 5 7 5}))
(define "Tri57Bug"  (tri {5 7 5 8 5}))
(define "Tri67Bug"  (tri {6 7 6 9 5}))
(define "Tri68Bug"  (tri {6 8 6 10 5}))
(define "Tri78Bug"  (tri {7 8 7 10 6}))
(define "Tri910Bug" (tri {9 10 10 13 7}))

(option "Board Size" <Board> args:{ <size> <diag> }
    {   
    (item "H 3 (19)"      <(tri Hexagon 3)>   <Hidden> "Board & size: Hexhex 3")
    (item "H1 3-4 (27)"   <(tri {3 4 3 4 3})> <Hidden> "Board & size: H1 Hexhex with edges alternating 3 and 4")
    (item "H 4 (37)"      <(tri Hexagon 4)>   <Hidden> "Board & size: Hexhex 4")
    (item "H 5 (61)"      <(tri Hexagon 5)>   <Hidden> "Board & size: Hexhex 5") 
    (item "H1 5-6 (75)"   <"Tri56Bug">        <Hidden> "Board & size: H1 Hexhex with edges alternating 5 and 6")
    (item "H 6 (91)"      <(tri Hexagon 6)>   <Hidden> "Board & size: Hexhex 6") 
    (item "H 7 (127)"     <(tri Hexagon 7)>   <Hidden> "Board & size: Hexhex 7")
    (item "H1 7-8 (147)"  <"Tri78Bug">        <Hidden> "Board & size: H1 Hexhex with edges alternating 9 and 10")
    (item "H1 9-10 (243)"  <"Tri910Bug">        <Hidden> "Board & size: H1 Hexhex with edges alternating 9 and 10")
    (item "H1 2-3 (12)"   <(tri {2 3 2 3 2})> <Hidden> "Board & size: H1 Hexhex with edges alternating 2 and 4")
    (item "H2 2-4 (18)"   <(tri {2 4 2 4 2})> <Hidden> "Board & size: H2 Hexhex with edges alternating 2 and 4")
    (item "H2 3-5 (36)"   <(tri {3 5 3 5 3})> <Hidden> "Board & size: H2 Hexhex with edges alternating 3 and 5")****
    (item "H1 4-5 (48)"   <(tri {4 5 4 5 4})> <Hidden> "Board & size: H1 Hexhex with edges alternating 4 and 5")
    (item "H2 4-6 (60)"   <"Tri46Bug">        <Hidden> "Board & size: H2 Hexhex with edges alternating 4 and 6")
    (item "Special (78)"   <(trim (remove (tri Hexagon 7) vertices:{0..34 42 43 44 45 54 55 56 57 67 68 69 80 81 92}))> <Hidden> "Board & size: Hexhex with opposing edges 4, 6 and 7")
    (item "H2 5-7 (90)"   <"Tri57Bug">        <Hidden> "Board & size: H2 Hexhex with edges alternating 5 and 7")
    (item "H2 5-7 truncated (84)"   <(trim (remove ("Tri57Bug") vertices:{0 6 34 44 85 89}))>        <Hidden> "Board & size: H2 Hexhex with edges alternating 5 and 7")
    (item "H1 6-7 (108)"  <"Tri67Bug">        <Hidden> "Board & size: Hexhex with edges alternating 6 and 7")
    (item "H2 6-8 (126)"  <"Tri68Bug">        <Hidden> "Board & size: H2 Hexhex with edges alternating 6 and 8")
    }
)

(option "Alternation" <Moves> args:{<perTurn>}
    {
    (item "Pure Single Turns"
        <1>  
        "
        Using triple turn rules: 
        "
    )
    (item "Pure Double Turns"
        <2>  
        "
        Using triple turn rules: 
        "
    )
    (item "Pure Triple Turns"
        <3>  
        "
        Using triple turn rules: 
        "
    )
    }
)
(option "Start" <Starting> args:{ <method> }
    {
    (item "Empty Placement" <"WithoutPie">
    "A player's first piec is placed on any empty space.")
    (item "Pie" <"WithPie">
    "Start by placing 2 Dark and one Light piece as a 'pie' offer.") 
    }
)

(rulesets
    {
    (ruleset "Ruleset/Garrisons" { "Board Size/H2 5-7 (90)" "Alternation/Pure Single Turns" "Start/Empty Placement" })
    }
)
//----------------------------------------------------------

(metadata
    (info
        {
        (description "Garrisons is an adaptation of my game Skirt in line with David Ploog's recommendations on avoiding cop-outs and making it easier for new players to learn.
            Differences: Small suggested board to learn with. No pie (or optional pie); single action turns; pieces age by stacking becoming immobile. No incentive to pass. Game ends when one player controls more than half the board (win) or both contorl exactly half. Continuing to play will make this condition clearer without changing the outcome (unless a player blunders)
            
        The skirting, then is the focus of the game and the main learning hurdle.")
        (rules "Garrisons Rules
            The Board presented here is for learning to play. Please select a larger board for an actual game between human players.
            
            Overview
            The game is played by placing or moving pieces (regiments) in order to occupy the most territory, and ends when it is clear who can do so.
            
            Regiments exert influence on the spaces around them. Their placement and movement is restricted by these influences.
            
            After moving, regiments become 'garrisoned', and can no longer move, but exert greater influence on the spaces around them. This is indicated by converting them to a 2-stack (garrison).
            
            Set-up:
            After choosing colors, Black starts by placing a regiment onto any empty position, and then White does the same. Note: Avoid starting on the edge. - A piece started on the edge can be easily boxed in.
            
            Play
            Players alternate taking turns as follows:
            A turn is either placing a regiment, or moving a regiment, but not both. There is no need to pass.
            
            Placing a regiment.
            A regiment is placed on any empty space where the friendly influence of the surrounding pieces is greater than the enemy's influence there. Regiments each contribute one influence, garrisons contribute 2. The piece being placed does not contribute influence.
            
            Moving a regiment.
            A regiment moves in a series of 'marches', each 'march' moving the regiment one step to a neighboring empty position, provided both that:
        1) -- The marching regiment maintains adjacency with (skirts) another piece during the 'march'. The adjacent piece may be of any type or ownership.
        (This keeps the piece from marching away from contact with the entire group pieces on the board, even if that march would bring it back into contact.)
    2) -- The position is not under the opponent's influence when entered. The influence of the moving piece IS counted.
    
    The same regiment may continue to march, skirting the same or successive pieces, or stop at any time. When it stops, a piece is stacked on top to show that it is now garrisoned, and will no longer move.
    
    Another way to think about #2 is that the regiment can enter positions where a regiment could have been placed, and also neutral positions that are next to existing pieces.
    
    Because the influence of the regiment itself is counted on arrival, far away locations that have an enemy influence of 1 will become neutral when the regiment arrives, and the regiment can thus march into them, as well.
    
    Territory and Ending the Game
    Your territory includes:
1) All the locations you occupy
2) All the locations that, if you were to pass until your opponent could no longer play, you could still reach with a series of your own moves.

There is a definite point when one player's territory exceeds 1/2 of the board and a win can be claimed. This would end the game in tournament play.

However it takes experience to see exactly when this occurs. There is no problem continuing to play until the result becomes visible; for example, when each playable region is fully surrounded by one color. Unless players make obvious blunders, the results will remain the same. Such blunders would only happen if a player does not yet realize they have won. For non-tournament play, the game is considered ended when play has actually stopped.

In rare cases, both players may gain control of exactly half of the positions that are not entirely blocked off from future play, thus tying the game. Territorial ties on a board with an odd number of playing positions require that an odd number of positions must become blocked, with neither player able reach them.

Board for regular play:
Minimum edge length 5.
To minimize draws, boards with odd numbers of playing positions are preferred. (eg. any regular hexagon)
For balance, boards should have alternating edge lengths and not be centered on a play position.
This suggests: Alternating edge hex boards of 5-6 (75); 7-8 (147); 9-10 (243)

Basic Emergent Tactics:
-- Placing regiments gives a player mobility;
-- Moving them to create garrisons gives defense.
-- Regiments cannot cross between enemy pieces located on a diagonal, and need assistance to march from one to the other.
-- Similarly two unfriendly garrisons block passage through a location directly between them.
Note: Regiments can easily skirt around and between these formations when they are friendly.

-- Placing a regiment next to another regiment, prevents an enemy regiment from marching from one to the other without assistance.
-- Creating a garrison by moving to the end of a line can prevent enemy regiments from marching around it without assistance.
-- Doing either of these near the edge of the board blocks movement around entirely.

-- Playing near (not on) the edge is an easy way to build and extend territory.
-- Playing toward the center from the opponent's edge pieces might allow you to cut off larger areas.
-- Playing a regiment next to an opponent's piece may allow him to reach areas that could not be reached before - for defense, leave a gap.
-- But placing a garrison against a opponent's piece - or just near it - can restrict placements between them.
-- Getting at least one piece onto the other side of a group is important to prevent the opponent from closing off large territories.

-- A arc of 3 that includes a garrison, joined with a similar arc of 3 to form a cup around 2 open positions makes those positions yours, and is very hard for the opponent to move around.

Options: For those who like tactical, puzzley games, and don't fall into analysis-paralysis *12 *23 protocols can be used for a higher branching factors. These would need to be played on larger boards.")
(id "4208")
(version "1.3.14")
(classification "board/space/blocking")
(publisher "Dale W. Walton")
(credit "Dale W. Walton")
(date "15-02-2024")
}
)

(graphics 
    {
    (board Style Graph)
    (board Colour InnerEdges (colour 62 72 55 150))
    (board Colour OuterEdges (colour 62 72 55 150))
(board Colour InnerVertices (colour LightGrey)) // (colour 170 160 140))
(board Colour OuterVertices (colour LightGrey)) // (colour 170 160 140))
(board StyleThickness OuterEdges .15)
(board StyleThickness InnerEdges .15)
(board Background fillColour:(colour HumanLight) edgeColour:(colour 170 160 140) scale:1.3)

(show Edges Diagonal <Board:diag> (colour 62 72 55))
(player Colour P1 (colour Black))    
(player Colour P2 (colour Cream))
(piece Scale "Disc" 0.7)
(region Colour ("TerritoryOf" 1) regionSiteType:Vertex (colour DarkGrey))
(region Colour ("TerritoryOf" 2) regionSiteType:Vertex (colour Cream))
(region Colour ("BlockedSites") regionSiteType:Vertex (colour Blue))
(show Piece State Middle)
}
)
(ai
    (bestAgent "Alpha-Beta")
    //  (heuristics
        //   {
        //    (centreProximity weight:.1) //to avoid piecemeal gains by following the edges
        //    (score weight:.2) //to prevent the abandonment of large scoring regions
        //    (lineCompletionHeuristic weight:-.3 targetLength:2) // to encourage diagonal arrangements
        //    (material weight:-.5) // to encourage taking the optional movement
    ////    influence weight:0.2)
    ////    (mobilitySimple weight:0.05)
    //   }
))

//)

