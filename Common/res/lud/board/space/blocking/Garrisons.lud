// Site definitions for scoring
(define "EmptyRegionPerimeter" (sites Around (sites Group at:(site) if:(is Empty (to)))))

(define "AllUnreachableSites"
 (difference
  (sites Board)
  (sites
   (union 
    {
     (values Remembered "R-P2")
     (values Remembered "R-P1")
     (values Remembered "RMax-P2")
     (values Remembered "RMax-P1")
    }
))))

(define "BlockedSites"   //sites
 (forEach 
  ("AllUnreachableSites")
  if:(and 
   (=
    (count Sites
     in:(intersection
      ("EmptyRegionPerimeter")
      (sites State 2)
    ))
    (count Orthogonal at:(site))
   )
   (all Sites
    (sites Group at:(site) if:(is Empty (to)))
    if:(=
     (count Sites in:(sites Around (site) if:(= 1 (who at:(to)))))
     (count Sites in:(sites Around (site) if:(= 2 (who at:(to)))))
)))))

//------------------------
// Utilities
//Mappings

(define "OpponentOf" (- 3 #1))

// Booleans

(define "IsPlaceableByAt" // (mover) (next)
 (> 
  (+
   (count Pieces of:#1 in:(sites Around #2))
   (count Pieces of:#1
    in:(sites Around #2 if:(= 2 (state at:(to))))
  ))
  (+
   (count Pieces of:("OpponentOf" #1) in:(sites Around #2 includeSelf:True))
   (count Pieces of:("OpponentOf" #1)
    in:(sites Around #2 if:(= 2 (state at:(to))) includeSelf:True)
))))

(define "MaintainsContact"  // The original location must be treated as empty.
 (not
  (no Pieces
   in:(difference
    (intersection
    (sites Around (from) Orthogonal)
     (sites Around (to) Orthogonal)
    )
    (var "LF")
))))

// the moving piece dynamically affects the territory count.  
(define "CanSkirtTo" // for mover during move
 (and 
  ("MaintainsContact")
  (>=
   (+ 
    {
     (if (is In (var "LF") (sites Around (from))) 0 1)   // For the moving piece without double counting at origin
     (count Pieces of:(mover)
      in:(sites Around (from))
     )
     (count Pieces of:(mover)
      in:(sites Around (from) if:(= 2 (state at:(to))))
     )
    }
   )
   (+
    (count Pieces of:(next)
     in:(sites Around (from))
    )
    (count Pieces of:(next)
     in:(sites Around (from) if:(= 2 (state at:(to))))
)))))

//------------------------------------------
// Moves
(define "Placement"
 (move Add 
  (piece (id "Disc" Mover))
  (to 
   (sites Empty)
   if:("IsPlaceableByAt" (mover) (to))
   (apply (set State at:(to) 1))
)))
 
(define "Skirting"
 (forEach Piece 
  (do
   (set Var "LF" (from))
   next:(if
    (= 1 (state at:(from)))
    (move
     (from)
     (to
      (sites Empty) 
      if:(!= Infinity
       (count Steps Orthogonal
        (step Orthogonal
         (to
          if:(and
           (is Empty (from)) 
           ("CanSkirtTo")
        ))) 
        (to) 
        (var "LF") // switch direction to test 
    ))))
    (then
     (set Var "SkirtCount" (+ (var "SkirtCount") 1)
      (then (set State at:(last To) 2))
    ))
)))) 

(define  "PieRefusal" 
 (move Swap Players 1 2
  (then
   (set Var "Offerer" 2)
)))
       
(define "Place3rdPiePiece"
 (move Add (piece (next)) 
  (to (sites Empty) (apply (set State at:(to) 1)))
 )
 (then (set Var "Offerer" 1))
)

(define "PlacePiePiece"
 (move Add (to (sites Empty) (apply (set State at:(to) 1)))
  (then
   (seq
    {
     (set Value P1 0)
     (set Value P2 0)
     (set Var "SkirtCount" 0)
     (set Var "PlacementCount" 0)
     (moveAgain)
    }
))))

//-------------------
// Game structure

(define "MoveOrPlace"
 (do
  (if
   ("NewTurn")
   (and 
    (set Var "SkirtCount" 0)
    (set Var "PlacementCount" 0)
  ))
  next:(or
   ("Placement")
   ("Skirting")
  ) 
  (then 
   (set Var "PlacementCount"
    (+ 1 (var "PlacementCount")) 
    (then
     (if
      (>
       <Moves:perTurn>
       (var "PlacementCount")
      )
      (moveAgain)
))))))

(define "TheGame" 
 (if
  (= 1 (mover))
  (do
   (and
    (forget Value "R-P1" All) 
    (forget Value "RMax-P2" All)
   )
   next:"MoveOrPlace"  // ("OriginalGame") // ("TwoPlusOneSkirtGame")
  )
  (do
   (and
    (forget Value "R-P2" All) 
    (forget Value "RMax-P1" All)
   )
   next:"MoveOrPlace"  // ("OriginalGame") // ("TwoPlusOneSkirtGame")
)))

(define "WithPie"
 (if
  (> 2 (counter))
  (if
   (= -1 (counter))
   ("PlacePiePiece" 0)
   (if
    (= 0 (counter))
    ("PlacePiePiece" 1)
    ("Place3rdPiePiece")
  ))
  (or
   (if
    (= 2 (counter))
    ("PieRefusal")
   )
   ("TheGame")
  )
  (then
   ("Score")
  ) 
))

(define "WithoutPie"
 (if
  (> 1 (counter))
  (move Add
   (to (sites Empty)
    (apply (set State at:(to) 1))
   )
  )
  ("TheGame")
  (then
   ("Score")
))) 

 
(define "MoveTrigger" (% (+ 1 (var "PlacementCount")) #1))
//---------------------------------------
// Main routine
//---------------------------------------
  
(game "Garrisons"
 (players 2)
 (equipment
  {
   (board <Board:size> use:Vertex)
   (piece "Disc" Each)
  }
 )
 (rules 
  (play
   <Starting:method>  // "WithPie" / "WithoutPie"
  )
  (end 
   (if
    (and
     (< 3 (counter))
     (<
      (- 
       (count Vertices)
       (var "CountOfBlockedSites") //set in the Scoring defines below
      )
      (max
       (array
        {
         (* 2 (score P1))  // P1 win
         (* 2 (score P2))  // P2 win
         (+ {1 (score P1) (score P2)}) // Tie
        }
    ))))
    (byScore)
))))

//----------------------------------------
// Scoring and End conditions
// Finding Reachable Sites for each player
// On a turn find the sites reachable considering everything as 1 stacks for the minimal case
// and the opponent's reachable sites considering all as 2 stacks for the maximal case.
// then subtract  the opponent's sites to get the mover's assured sites.

(define "CountOfPiecesOfAround"   // an integer  // arguments: <skirter:int>; <reachable sites so far> 
 // This is a work around for (count Pieces ... ) 
 // as iterator 'from' has distinct meaning in (count Steps (step ...))
 // and I need all pieces, not just sites.
 (+
  (count Sites
   in:(intersection
    (sites Occupied by:(player #1)) 
    (sites Around #2)
  ))
  (count Sites
   in:(intersection
    (sites Occupied by:(player #1)) 
    (sites Around #2 if:(= 2 (state at:(to))))
))))
 
// No placing can happen at sites where opponent has enough actual piece to foever block entry even using stacks 

(define "NotExcludedToSite" // boolean  // arguments: <Stack height:int>, <skirter:int>
// This prevents including sites that could be blocked later in the game, from inclusion in the minimal list
 (or
  (!= 2 #1)
  (>
   (count Sites
    in:(sites Around #3
     if:(not
      (is In (to) (sites Occupied by:(player ("OpponentOf" #2))))
   )))
   (/ ("CountOfPiecesOfAround" ("OpponentOf" #2) #3) 2)
)))

(define "StepRestrictionForSkirting" // boolean // arguments: e.g.  "SitesSoFarOf" or (sites {(from)}), 1 <i.e. player index>, Stack height
// This enforces the skirting movement destination influence requirement for sites to be added to the list using skirting. 
 (>=
  (+ 1 
   (- 
    (*
     #3
     (size Array
      (array
       (intersection #1
        (difference
         (sites Around (from))
         (sites {(to)})
    )))))
    (if
     (= 1 #3)
     0
     // subtract 1 fo each actual neighboring single
     (size Array
      (array
       (difference
        (sites Around (from)
         if:(and
          (is In (to) (sites Occupied by:(player #2)))
          (= 1 (state at:(to))) // restricted to real stacks of 1
        ))
        (sites {(to)}) // not counting the source site 
        // from which the moving piece came
  ))))))
  ("CountOfPiecesOfAround" ("OpponentOf" #2) (from))
))

(define "AdjacencyRestrictionForSkirting"  // boolean // arguments:  e.g.  "SitesSoFarOf" or (sites {(from)})
// This enforces the skirting movement adjacency requirement for sites to be added to the list using skirting.
 (< 0
  (count Sites 
   in:(intersection
    (sites Around (from)) 
    (sites Around (to)
     if:(or
      (not (is Empty (to))) 
      (is In (to) #1)
))))))

(define "CanBeReachedBySkirting"  // boolean // arguments: e.g.  "SitesSoFarOf" or (sites {(from)}), 1 <i.e. player index> , Stack height
// This enforces all the restrictions for finding sites that can be added to the list by Skirting
 (and
  {
   (or
    {    
     (is Empty (to)) // not yet traced back to source
     (and
      (is In (to) #1) // traced back to friendly potential source
      (!= 2 (state at:(to))) // that is not an existing stack
     )
    }
   )
   // Meets skirting restrictions
   ("AdjacencyRestrictionForSkirting" #1)  
   ("StepRestrictionForSkirting" #1 #2 #3)
  }
))

(define "AppendReachOf"  // boolean // arguments: e.g.  "R-P1", 1, ("SitesSoFarOf" "R-P1"), maxStack height
// This adds reachable sites to the list for placements and for skirting, 
// when enforcing all relavent restrictions 
 (forEach Site
  (difference (sites Empty) #3)
  (if
   (or
    // can be reached by placements where skirting is not possible
    (and
     {
      ("NotExcludedToSite" #4 #2 (site)) 
      (>
       (+
        (* #4 (size Array (array (intersection #3 (sites Around (site))))))
        (if
         (= 1 #4)
         // for use by "R-Pn"  with 2 stacks (#4 is 1 so that potential sites are assumed minimal) 
         (count Pieces of:#2 in:(sites Around (site) if:(= 2 (state at:(to)))))
         // for use by "RMax-Pn" with 2 stacks (#4 is 2 so that potential sites are assumed maximal)       
         (- 0 (count Pieces of:#2 in:(sites Around (site) if:(= 1 (state at:(to))))))
       ))
       ("CountOfPiecesOfAround" ("OpponentOf" #2) (site))
      )
     }
    )
    (!=
     Infinity
     (count Steps
      (step
       (to      
        if:(or
        { 
         // can be reached by placements where skirting is not possible
         (no Pieces in:(sites Around (from)))
         
         // can be reached by skirting
         ("CanBeReachedBySkirting" #3 #2 #4)
        }
      )))
      (site)
       #3
   )))
   (remember Value #1 (site) unique:True)
  )
  
))

(define "SitesSoFarOf" (sites (values Remembered #1)))  // Readability aid

(define "ReachLoop" 
// Starting with the piece locations as a basis, 
// this loop adds sites to the reachable sites list until noe are left to add.
 (seq
  { 
   ("AppendReachOf" #1 #2 ("SitesSoFarOf" #1) #3)
   (while
    (>
     (size Array (values Remembered #1)) 
     (var #1)
    )
    (seq
     {
      (set Var #1 (size Array (values Remembered #1)))
      ("AppendReachOf" #1 #2 ("SitesSoFarOf" #1) #3)
     }  
   ))
  }
))

(define "RememberReachOf" // e.g.  "R-P1" or "RMax-1", <player>, stack height to consider  1 or 2
// This regenerates the potential reach lists
 (forEach Site
  (sites Occupied by:(player #2))
  (remember Value #1 (site) unique:True) 
  (then
   (set Var #1 (size Array (values Remembered #1))
   (then ("ReachLoop" #1 #2 #3)))
)))

//-------------
// Find the territories (used for Scoring, display, and ending the game)

(define "BlockableSites" // <region> // args: Stack height, skirter
// This lists the sites that could be become blocked later 
// in order to exclude them from the players confirmed territory
 (forEach
  (sites Empty)
  if:(and 
   (=
    (count Orthogonal at:(site)) 
    ("CountOfPiecesOfAround" #1 (site))
   )
   (=
    (count Orthogonal at:(site))
    (* 2
     (count Sites
      in:(sites Around (site)
       if:(is In (to) (sites (values Remembered #2)))
)))))))


(define "TerritoryOf" // <region> //args: 1 or 2
// This defines territory as the difference between assured reachable sites
// (i.e. from which potentially blockable sites have been excluded) 
// and the opponent's maximal reachable sites

 (if
  (= 1 #1)
  (sites
   (difference
    (values Remembered "R-P1")
    (union
     {
      (array ("BlockableSites" #1 "RMax-P2"))
      (values Remembered "RMax-P2")
     }
  )))
  (sites
   (difference
    (values Remembered "R-P2")
    (union
     {
      (array ("BlockableSites" #1 "RMax-P1"))
      (values Remembered "RMax-P1")
     }
))))) 

//-------------------------------
// Main Territory update routines

(define "UpdateScore"  // subrountine to update territory and scores
 (do
  (seq
   {
    ("RememberReachOf" #1 #2 1)  // 1 for "R-"
    ("RememberReachOf" #3 #4 2)  // 2 for  "RMax-"
   }
  )
  next:(set Score (player #2)
   (size Array (array ("TerritoryOf" #2)))
)))

(define "Score" 
// This drives the territory calculations for the appropriate player
// Including making a count of the actual blocked sites as of the last turn
 (if
  (= 1 (mover))
  ("UpdateScore" "R-P1" 1 "RMax-P2" 2)  
  ("UpdateScore" "R-P2" 2 "RMax-P1" 1)
  (then
   (set Var "CountOfBlockedSites"
    (count Sites in:("BlockedSites")) // note: only updates after opponents turn, since RMax is not recalculated until then
))))


//------------------------------------------------------

//---------------------------------------

(define "Tri46Bug"  (tri {4 6 4 7 4}))
(define "Tri56Bug"  (tri {5 6 5 7 5}))
(define "Tri57Bug"  (tri {5 7 5 8 5}))
(define "Tri67Bug"  (tri {6 7 6 9 5}))
(define "Tri68Bug"  (tri {6 8 6 10 5}))
(define "Tri78Bug"  (tri {7 8 7 10 6}))
(define "Tri910Bug" (tri {9 10 10 13 7}))

(option "Board Size" <Board> args:{ <size> <diag> }
 {   
  (item "H 3 (19)"      <(tri Hexagon 3)>   <Hidden> "Board & size: Hexhex 3")
  (item "H1 3-4 (27)"   <(tri {3 4 3 4 3})> <Hidden> "Board & size: H1 Hexhex with edges alternating 3 and 4")
  (item "H 4 (37)"      <(tri Hexagon 4)>   <Hidden> "Board & size: Hexhex 4")
  (item "H 5 (61)"      <(tri Hexagon 5)>   <Hidden> "Board & size: Hexhex 5") 
  (item "H1 5-6 (75)"   <"Tri56Bug">        <Hidden> "Board & size: H1 Hexhex with edges alternating 5 and 6")
  (item "H 6 (91)"      <(tri Hexagon 6)>   <Hidden> "Board & size: Hexhex 6") 
  (item "H 7 (127)"     <(tri Hexagon 7)>   <Hidden> "Board & size: Hexhex 7")
  (item "H1 7-8 (147)"  <"Tri78Bug">        <Hidden> "Board & size: H1 Hexhex with edges alternating 9 and 10")
  (item "H1 9-10 (243)"  <"Tri910Bug">        <Hidden> "Board & size: H1 Hexhex with edges alternating 9 and 10")
  (item "H1 2-3 (12)"   <(tri {2 3 2 3 2})> <Hidden> "Board & size: H1 Hexhex with edges alternating 2 and 4")
  (item "H2 2-4 (18)"   <(tri {2 4 2 4 2})> <Hidden> "Board & size: H2 Hexhex with edges alternating 2 and 4")
  (item "H2 3-5 (36)"   <(tri {3 5 3 5 3})> <Hidden> "Board & size: H2 Hexhex with edges alternating 3 and 5")****
  (item "H1 4-5 (48)"   <(tri {4 5 4 5 4})> <Hidden> "Board & size: H1 Hexhex with edges alternating 4 and 5")
  (item "H2 4-6 (60)"   <"Tri46Bug">        <Hidden> "Board & size: H2 Hexhex with edges alternating 4 and 6")
  (item "Special (78)"   <(trim (remove (tri Hexagon 7) vertices:{0..34 42 43 44 45 54 55 56 57 67 68 69 80 81 92}))> <Hidden> "Board & size: Hexhex with opposing edges 4, 6 and 7")
  (item "H2 5-7 (90)"   <"Tri57Bug">        <Hidden> "Board & size: H2 Hexhex with edges alternating 5 and 7")
  (item "H2 5-7 truncated (84)"   <(trim (remove ("Tri57Bug") vertices:{0 6 34 44 85 89}))>        <Hidden> "Board & size: H2 Hexhex with edges alternating 5 and 7")
  (item "H1 6-7 (108)"  <"Tri67Bug">        <Hidden> "Board & size: Hexhex with edges alternating 6 and 7")
  (item "H2 6-8 (126)"  <"Tri68Bug">        <Hidden> "Board & size: H2 Hexhex with edges alternating 6 and 8")
 }
)

(option "Alternation" <Moves> args:{<perTurn>}
 {
  (item "Pure Single Turns"
   <1>  
  "
  Using triple turn rules: 
  "
  )
  (item "Pure Double Turns"
   <2>  
  "
  Using triple turn rules: 
  "
  )
  (item "Pure Triple Turns"
   <3>  
  "
  Using triple turn rules: 
  "
  )
 }
)
(option "Start" <Starting> args:{ <method> }
 {
  (item "Empty Placement" <"WithoutPie">
   "A player's first piec is placed on any empty space.")
  (item "Pie" <"WithPie">
   "Start by placing 2 Dark and one Light piece as a 'pie' offer.") 
 }
)

(rulesets
 {
  (ruleset "Ruleset/Garrisons" { "Board Size/H2 5-7 (90)" "Alternation/Pure Single Turns" "Start/Empty Placement" })
 }
)
//----------------------------------------------------------

(metadata
 (info 
  {
  }
 )

 (graphics 
    {
    (board Style Graph)
    (board Colour InnerEdges (colour 62 72 55 150))
    (board Colour OuterEdges (colour 62 72 55 150))
    (board Colour InnerVertices (colour LightGrey)) // (colour 170 160 140))
    (board Colour OuterVertices (colour LightGrey)) // (colour 170 160 140))
    (board StyleThickness OuterEdges .15)
    (board StyleThickness InnerEdges .15)
    (board Background fillColour:(colour HumanLight) edgeColour:(colour 170 160 140) scale:1.3)
   
    (show Edges Diagonal <Board:diag> (colour 62 72 55))
    (player Colour P1 (colour Black))    
    (player Colour P2 (colour Cream))
    (piece Scale "Disc" 0.7)
    (region Colour ("TerritoryOf" 1) regionSiteType:Vertex (colour DarkGrey))
    (region Colour ("TerritoryOf" 2) regionSiteType:Vertex (colour Cream))
    (region Colour ("BlockedSites") regionSiteType:Vertex (colour Blue))
    (show Piece State Middle)
   }
 )
 (ai
  (bestAgent "Alpha-Beta")
//  (heuristics
//   {
//    (centreProximity weight:.1) //to avoid piecemeal gains by following the edges
//    (score weight:.2) //to prevent the abandonment of large scoring regions
//    (lineCompletionHeuristic weight:-.3 targetLength:2) // to encourage diagonal arrangements
//    (material weight:-.5) // to encourage taking the optional movement
////    influence weight:0.2)
////    (mobilitySimple weight:0.05)
//   }
 ))
  
//)


