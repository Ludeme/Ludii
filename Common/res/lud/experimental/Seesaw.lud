(define "Deploy"
    (move Add (piece (id "Hex" Mover))
        (to
            (sites Around
                (sites Occupied by:Mover component:"Hex" top:False)
            )
            if:(is Empty (to))
        )
        (then
            (add (piece (id "Disc" Mover))
                (to (last To))
                stack:True
            )
        )
    )
)

(define "Step"
    (do
        (if (= 0 (count MovesThisTurn))
            ("ResetMoveCount")
        )
        next:(move
            (from
                if:(=
                    (*
                        (from)
                        (if (< 0 (count MovesThisTurn)) 1 0)
                    )
                    (*
                        (last To)
                        (if (< 0 (count MovesThisTurn)) 1 0)
                    )
                )
            )
            (to
                ("EmptyInRange")
            )
            count:("StackSize" (from))
            stack:True
        )
    )
)

(define "ResetMoveCount"
    (set Var ("StackSize" (from)))
)

(define "DeductMoves"
    (set Var
        (-
            (var)
            ("StepsTaken")
        )
        #1
    )
)

(define "Capture"
    (do
        (if
            (= 0 (count MovesThisTurn))
            ("ResetMoveCount")
        )
        next:(move
            (from
                if:(=
                    (*
                        (from)
                        (if (< 0 (count MovesThisTurn)) 1 0)
                    )
                    (*
                        (last To)
                        (if (< 0 (count MovesThisTurn)) 1 0)
                    )
                )
            )
            (to
                ("CaptureRange")
                (apply
                    (remove (to) count:("StackSize" (to)))
                )
            )
            count:("StackSize" (from))
            stack:True
        )
    )
)

(define "StackSize"
    (count Stack
        at:#1
        if:(or
            (=
                (id "Disc" Next)
                (what at:(to) level:(level))
            )
            (=
                (id "Disc" Mover)
                (what at:(to) level:(level))
            )
        )
    )
)

(define "EmptyInRange"
    (if
        (is Odd ("StackSize" (from)))
        (sites Distance
            (step
                Forwards
                (to
                    if:(= 0 ("StackSize" (to)))
                )
            )
            from:(from)
            (range 1 (var))
        )
        (sites Distance
            (step
                Backwards
                (to
                    if:(= 0 ("StackSize" (to)))
                )
            )
            from:(from)
            (range 1 (var))
        )
    )
)

(define "StepsTaken"
    (count Steps
        (step
            (to
                if:(or
                    (= (last To) (to))
                    (= 0 ("StackSize" (to)))
                )
            )
        )
        (last From)
        (last To)
    )

)

(define "Promotes"
    (=
        (+
            (* 1 (% ("StackSize" #1) 2))
            (%
                (mover)
                (-
                    3
                    (% ("StackSize" #1) 2)
                )
            )
        )
        (*
            (who at:#1 level:0)
            (count Stack
                at:#1
                if:(or
                    (=
                        (id "Hex" Next)
                        (what at:(to) level:(level))
                    )
                    (=
                        (id "Hex" Mover)
                        (what at:(to) level:(level))
                    )
                )
            )
        )
    )
)

(define "Promote"
    (if
        ("Promotes" (last To))
        (add (piece (id "Disc" Mover))
            (to (last To))
            stack:True
        )
    )
)

(define "Reachable"
    (sites Distance
        (step
            (to
                if:(= 0 ("StackSize" (to)))
            )
        )
        from:(from)
        (range 1 (- #1 1))
    )
)

(define "CaptureRange"
    (if
        (> (var) 1)
        (intersection
            (sites Around
                (intersection
                    ("Reachable" (var))
                    (sites Around
                        (sites Occupied by:Enemy component:"Disc")
                    )
                )
            )
            (sites Occupied by:Enemy component:"Disc")
        )
        (intersection
            (sites Around (from))
            (sites Occupied by:Enemy component:"Disc")
        )
    )
)

//------------------------------------------------------------------------------

(game "Seesaw"
    (players {(player N) (player S)})
    (equipment
        {
        (board (rotate 30 (hex <Board>)))
        (piece "Disc" Each)
        (tile "Hex" Each)
        }
    )
    (rules
        (start {
            (place Stack "Hex1" 0)
            (place Stack "Disc1" 0)
            (place Stack "Hex2" (* <Board> (* 3 (- <Board> 1))))
            (place Stack "Disc2" (* <Board> (* 3 (- <Board> 1))))
        })
        (play
            (if
                (can Move
                    (forEach Piece "Disc"
                        ("Capture")
                        top:True
                    )
                )
                (forEach Piece "Disc"
                    ("Capture")
                    top:True
                    (then
                        ("DeductMoves"
                            (then
                                (if
                                    (< 0 (var))
                                    (moveAgain)
                                    ("Promote")
                                )
                            )
                        )
                    )
                )
                (if
                    (< 0 (count MovesThisTurn))
                    (or
                        (forEach Piece "Disc"
                            ("Step")
                            top:True
                        )
                        (move Pass)
                        (then ("Promote"))
                    )
                    (or
                        (forEach Piece "Disc"
                            ("Step")
                            top:True
                            (then ("Promote"))
                        )
                        ("Deploy")
                    )
                )
            )
        )
        (end
            (if
                (= 0
                    (count Sites
                        in:(sites Occupied by:Next component:"Disc")
                    )
                )
                (result Next Loss)
            )
        )
    )
)

//------------------------------------------------------------------------------

(option "Board Size" <Board> args:{ <size> }
    {
    (item "4"    <4>  "A base 4 board is currently selected")*
    (item "5"    <5>  "A base 5 board is currently selected")
    }
)

//------------------------------------------------------------------------------

(metadata
    (info
        {
        (description "Seesaw is a Draughts-inspired elimination game invented by Alek Erickson and Michael Amundsen in 2021.")
        (rules "Overview:
            In Seesaw the players (North and South) command opposing armies with soldiers that can promote. Your army starts out as a single soldier and your promotion area evolves as you deploy more soldiers. Every time a soldier promotes it grows - first into a 2-stack, then a 3-stack, and so on.

            The central idea of Seesaw is the 2-fold significance of stack-size:
            (i) Odd-sized stacks move forwards and even-sized stacks move backwards, and
            (ii) on any given turn, a stack can take as many steps as it likes from 1 up to its size.

            This results in soldiers seesawing up and down the board as their strength increases to the point where the game is forced to conclude in one side completely eliminating the other.

            How to play:
            On your turn, you must either make a stack-move, or place a new stack.

            1. Placing a new stack:
            A newly placed stack will always be of size 1. You may only place a stack on an empty cell next to a cell of your color. These cells are promotion cells, and each cell you place a new stack on automatically turns into a promotion cell of your color.

            2. Stackmoves:
            You only ever move one stack per turn, but that stack may be able to move several steps or capture several enemiy stacks, depending on its size.
            The number of steps a stack may take is the number of pieces in it, i.e. its size.

            2.1 Noncapturing moves: On turns where you do not have to capture an enemy (see below) all the steps a stack takes is either constrained to the 3 upward directions or to the 3 downward directions, depending on the size and the owner of the stack. South's forward directions are the 3 upward directions, and North's forward directions are the 3 downward directions.

            2.2 Capturing moves: If one or more of your stacks can reach an enemy by lifting the restraint on direction, you must capture such a reachable enemy by replacement. If that stack did not spend all its steps reaching the captured enemy, you can, before you end your turn, spend the left-over steps by making a noncapturing move. However, if yet an enemy is in range immediately after you have captured (counting only the steps left over), you must capture again.

            3. Promoting: Your odd-sized stacks promote when they end up on a promotion cell belonging to your opponent at the end of your turn. Your even-sized stacks promote when they end up on a promotion cell belonging to you at the end of your turn.

        The object of Seesaw is to capture all your opponent's soldiers. More precisely: If, at the end of your turn, your opponent has no stacks on the board, you have won the game.")
        (version "1.3.0")
        (classification "experimental")
        (author "Alek Erickson and Michael Amundsen")
        (credit "Alek Erickson and Michael Amundsen")
        (date "2021")
        }
    )
    (graphics {
        (player Colour P1 (colour Cream))
        (player Colour P2 (colour Grey))
        (piece Colour P1 "Hex" fillColour:(colour 255 255 230 200))
        (piece Colour P2 "Hex" fillColour:(colour 150 150 150 200))
        (region Colour (sites Board) (colour 250 210 148))
        (board Colour InnerEdges (colour 178 151 100))
        (board Colour OuterEdges (colour 178 151 100))
        (stackType Default 0.7)
    })
)
