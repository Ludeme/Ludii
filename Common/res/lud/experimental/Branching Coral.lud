//
(define "GroupCount"
    (max 0
        (max
            (sizes Group "ScoreConnectionDirection" #1) 
        )
    )
)

//---------------------
// Defines for scoring options

(define "GroupScore"
    (set Var "MoverScore" ("GroupCount" Mover)
        (then
            (set Var "NextScore" ("GroupCount" Next)
                (then
                    <TieScoring:tiebreaker> 
                )
            )
        )
    )
)

(define "PlusCaptureScore" // Captures + cascade scoring
    (set Var "MoverScore"
        (+
            (value Piece at:(handSite Mover))
            ("GroupCount" Mover)
        )
        (then
            (set Var "NextScore"
                (+
                    (value Piece at:(handSite Next))
                    ("GroupCount" Next)
                )
                (then 
                    <TieScoring:tiebreaker> 
                )
            )
        )
    )
)

(define "BonusMover"
    (set Var "MoverScore"
        (+ 
            ("GroupCount" Mover)
            (count Groups "ScoreConnectionDirection" if:(= (who at:(to)) (mover))) 
        )
        (then
            (set Var "NextScore"
                (+ 
                    ("GroupCount" Next)
                    (count Groups "ScoreConnectionDirection" if:(= (who at:(to)) (next))) 
                )
                (then
                    <TieScoring:tiebreaker> 
                )
            )
        )
    )
)

(define "BonusOpponent"
    (set Var "MoverScore"
        (+ 
            ("GroupCount" Mover)
            (count Groups "ScoreConnectionDirection" if:(= (who at:(to)) (next))) 
        )
        (then
            (set Var "NextScore" 
                (+ 
                    ("GroupCount" Next)
                    (count Groups "ScoreConnectionDirection" if:(= (who at:(to)) (mover))) 
                )
                (then
                    <TieScoring:tiebreaker> 
                )
            )
        )
    )
)

//---------------------------
// Defines for Tiebreaker scoring option

(define "CascadeScore" 
    (max 0
        (max
            (difference
                (sizes Group "ScoreConnectionDirection" #1)
                (sizes Group "ScoreConnectionDirection" #2)
            )
        )
    )
)

(define "NoTiebreaker"
    (and
        (set Score Mover (var "MoverScore")) 
        (set Score Next (var "NextScore")) 
    )
)

(define "CascadeTiebreaker"
    (if 
        (= (var "MoverScore") (var "NextScore")) 
        (and
            (set Score Mover (- 0 ("CascadeScore" Mover Next)))
            (set Score Next (- 0 ("CascadeScore" Next Mover)))
        )
        ("NoTiebreaker")
    )
)

//----------------------------
(define "CaptureScores" 
    (forEach Value
        (array #1)
        (if 
            (> 2 (count Sites in:(sites Around (value) "ConnectionDirection" if:(is Empty (to)))))
            (if
                (is Mover (who at:(value))) 
                (remove (value))
                (remove (value)
                    (then
                        (if
                            (is Empty (handSite Mover))
                            (add (piece (id "Disc" Next)) (to (handSite Mover))
                                (then
                                    (set Value at:(handSite Mover) (+ 1 (value Piece at:(handSite Mover))))
                            ))
                            (set Value at:(handSite Mover) (+ 1 (value Piece at:(handSite Mover))))
                        )
                    )
                )
            )
        )
    )
)

(define "Capture" 
    (forEach Value
        (array #1)
        (if 
            (> 2 (count Sites in:(sites Around (value) "ConnectionDirection" if:(is Empty (to)))))
            (remove (value))   
        )
    )
)

(define "AllHave1Connection2Edge"
    (all Sites
        #1
        if:(or
            (and 
                (is Empty (site))
                (is In (site) (sites Outer))
            )
            (!= Infinity
                (count Steps
                    (step "ConnectionDirection"
                        (to if:(is Empty (to)))
                    )
                    (site)
                    (difference (sites Outer) (site))
                )
            )
        )
    )
)

//-----------------------------------------------
// Main routine

(game "Branching Coral"
    (players 2)
    (equipment {
        "BoardUsed"
        (piece "Ball" Each)
        (piece "Disc" Each)
        <Scoring:handType>
    })
    (rules
        (start (set Score Each 0))
        (play
            (do
                (move 
                    Add
                    (to 
                        (sites Empty) 
                        if:(< 1 
                            (count Sites 
                                in:(intersection
                                    (sites Around (to) "ConnectionDirection")
                                    (sites Empty)
                                )
                            )
                        )
                    )
                )
                ifAfterwards:("AllHave1Connection2Edge" 
                    (intersection 
                        (sites Around (last To) "ConnectionDirection")
                        (sites Empty)
                    )
                ) 
                (then
                    (do
                        (<Scoring:captureType> 
                            (intersection 
                                (sites Occupied by:All) 
                                (sites Around (last To) "ConnectionDirection") 
                        ))
                        next:(<Scoring:selScoring>)
                    )
                )
            )
        )
        (end 
            (if 
                (no Moves Next) {
                (if 
                    (= (score Mover) (score Next))
                    <TieScoring:finalTie>
                )
                (if 
                    (!= (score Mover) (score Next))
                    (byScore)
                )
            })
        )
    )
)

/-----------------------------------------
// Defines for Options

(define "ScoreConnectionDirection" <BoardShape:directionScored>)
(define "ConnectionDirection" <BoardShape:directionUsed>)
(define "BoardUsed" <BoardShape:gridType>)

(define "HexLimp" (board (hex Limping (- <BoardSize:smallSide> 1)) use:Cell))
(define "Hex2Limp" (board (hex (- <BoardSize:smallSide> 1) (+ <BoardSize:smallSide> 1)) use:Cell))
(define "HexCell" (board (hex Hexagon <BoardSize:smallSide>) use:Cell))
(define "TriSquare" (board (tiling T33434 (- <BoardSize:smallSide> 2)) use:Vertex))

//-------------------------------------------------
// Options

(option "Size" <BoardSize> args:{<smallSide>} 
    {
    (item "3 (5 moves each)" <3> "Order 3 board - about 5 moves each")
    (item "4 (11 moves each)" <4> "Order 4 board - about 11 moves each")
    (item "5 (17 moves each)" <5> "Order 5 board - about 17 moves each")*
    (item "6 (27 moves each)" <6> "Order 6 board - about 27 moves each")
    (item "7 (40 moves each)" <7> "Order 7 board - about 40 moves each")
    (item "8 (55 moves each)" <8> "Order 8 board - about 55 moves each")
    (item "9 (70 moves each)" <9> "Order 9 board - about 70 moves each")
    (item "11 (105 moves each)" <11> "Order 11 board - about 105 moves each")
    }
)

(option "Board Grid" <BoardShape> args:{<gridType> <directionUsed> <diagShow> <directionScored> <backgroundImage>} 
    {
    
    (item "TriSquare connections to edge All directions - Orthogonal only form groups"
        <"TriSquare"> <All> <ThinDotted> <Adjacent> <"Disc"> 
    "Triangle-Square N-2 all directions connect paths to edge - Orthogonal only form groups, about 20% more moves")
    
    (item "TriSquare connections to edge orthogonal only - All directions form groups"
        <"TriSquare"> <Adjacent> <Hidden> <All> <"Disc"> 
    "Triangle-Square N-2 Orthogonal connections to edge - ALl direction form groups")
    
    (item "Hex Limping"
        <"HexLimp"> <Orthogonal> <Hidden> <Orthogonal> <"Disc"> 
    "Hex N / N-1 Grid, about 5% less moves")*
    
    (item "Hex Double Limping"
        <"Hex2Limp"> <Orthogonal> <Hidden> <Orthogonal> <"Disc"> 
    "Hex N+1 / N-1 Grid")
    
    (item "Hex Grid"
        <"HexCell"> <Orthogonal> <Hidden> <Orthogonal> <"Disc"> 
    "Hex Grid - Standard")
    
    }
)

(option "Bonus Goal" <Scoring> args:{<selScoring> <handType> <captureType>}
    {
    
    (item "Captured opponent's pieces"
        <"PlusCaptureScore"> <(hand Each size:1)> <"CaptureScores"> 
    "Scoring Option: Score a point for each piece in your largest group and each opponent piece you capture")***
    
    (item "Number of mover groups"
        <"BonusMover"> <> <"Capture"> 
    "Scoring Option: Score the size of your largest group, then score an additional point for every group you have on the board.")**
    
    (item "Number of opponent's groups"
        <"BonusOpponent"> <> <"Capture"> 
    "Scoring Option: Score the size of your largest group, then score an additional point for every opponent's group on the board.")
    
    (item "No Bonus: Largest group size only"
        <"GroupScore"> <> <"Capture"> 
    "Scoring Option: No bonus. Score a point only for each piece in your largest group")
    
    }
)

(option "TieBreaker" <TieScoring> args:{<tiebreaker> <finalTie>}
    {
    
    (item "A: Largest group, cascading LOSES"
        <("CascadeTiebreaker")> <(result Mover Win)> 
    "Tiebreaker is largest group (excluding tied pairs) LOSES. If all are paired, last placement wins.")**
    
    (item "B: Last to place"
        <("NoTiebreaker")> <(result Mover Win)> 
    "Tiebreaker is last to place wins.")
    
    }
)

//---------------------------------------------
(define "ColourBackground" (colour 126 130 156)) 

(metadata
    (info
        {
        (description "Branching Coral is a placement game based on the principle of placing pieces, such that, after placement, every site on the boards still has a connection via empty sites to an empty site at the perimeter.                 Branching Coral differs from its parent game Brain Coral by having a capture mechanism: After placement, all the neighbouring stones with less than 2 adjacent empty sites are simultaneously captured. The placed piece itself must have 2 adjacent empty spaces before the captures to be a legal placement.             These capture conditions assure that the game is finite, and that the ending patterns that form are varied and gracefully branched, without thick regions either of pieces or empty space.                            Scoring is based on the size of the largest group plus a bonus factor.     The standard bonus factor is number of opponent's pieces captured.  This works to reward capture and thus encourages breaking up opponent's groups, while remaining straight forward in the need to enlarge your largest group, it allows creating come-back groups, or staging combacks by capturing material.              Other bonus options are:    Bonus for number of your own groups, serving to encourage you to make one large group and many singletons, to break up your opponent's largest group, and to try to force the opponent to connect small groups into medium-sized groups. This is similar to Brain Coral, with the added tactical element of capture.             Bonus for number of opponent's groups; which is less interesting because it encourages players to form large clumps and to break up and limit opponent's group growth, and potentially partial mimicry in play. Playing without any bonus, is similar to opponent group count bonus, but even more straight forward. It leads to clumping, though there still is a need for defence from captures severing connections. In this version the game will normally be decided early because neither player can extend nor break the critical group, and there is not enough space to create a larger one. Thus, this option needs the largest boards. The standard tiebreaker is for the underdog to win based on the largest cascading group size without bonus. If all groups are paired in size with the opponent, last to play wins.     For informal play, the tiebreaker can be simplified as last-to-place.")
        (rules "Goal: Score the most points: 
            -- One point for each stone in one's largest group.
            -- Bonus points are also awarded according to the selected option.
            
            The board starts empty.
            Players take alternating turns placing one of their stones onto an empty site.
            Directly after placement, every site of the board must remain connected to an empty perimeter site via a continuous path of empty sites, and the stone that was placed must be next to any 2 empty sites. 
            
            Capture 
            After placement, simultaneously remove all the stones adjacent to the placed stone that are no longer next to 2 empty sites.
            
            There is no passing. The game ends when no more placements can be made.  
            
            Players score one point for every stone in their largest group, then, if applicable, score bonus points according to the selected option.
            
            Bonus Options are:
            -- Captured opponent's stones
            -- Count of one's own groups
            -- Count of the opponent's groups
            -- No Bonus
            
            The player with the higher score wins. If the scores are tied, the game is decided by the tie-breaker option that was selected before the game: 
            A: Cascading largest group LOSES -- i.e. negative scores -- This excludes tied pairs; If all groups are paired, last to place. 
        B: Last player to have placed a stone.")
        (id "1660")
        (version "1.3.12")
        (classification "experimental")
        (author "Dale W. Walton")
        (credit "Dale W. Walton")
        (date "06-05-2021")
        }
    )
    
    (graphics 
        {
        (player Colour P1 (colour 120 36 0))
        (player Colour P2 (colour Cream))
        (piece Scale "Ball" 0.95)
        (piece Scale "Disc" 0.70)
        (piece Background "Ball" image:"Disc" fillColour:(colour 0 0 0 130) edgeColour:(colour 0 0 0 130)) 
        (board Colour Phase0 "ColourBackground")
        (board StyleThickness InnerEdges 0.4)
        (board StyleThickness OuterEdges 0.6)
        (board StyleThickness InnerVertices 0.45)
        (board StyleThickness OuterVertices 0.45)
        (board Colour InnerVertices (colour Grey))
        (board Colour OuterVertices (colour Grey))
        (board Colour InnerEdges (colour Black))
        (board Colour OuterEdges (colour Black))
        (show Edges Diagonal <BoardShape:diagShow> (colour DarkGrey))
        (show Piece Value "Disc" Middle)
        (board Background image:<BoardShape:backgroundImage> fillColour:"ColourBackground" edgeColour:"ColourBackground" scaleX:1.2 scaleY:1.15) 
        }
        )    (ai
        "Branching Coral_ai"
    )
)

